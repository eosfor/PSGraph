// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using PSGraph.Vega.Spec;
//
//    var vega = Vega.FromJson(jsonString);

namespace PSGraph.Vega.Spec
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class Vega
    {
        [JsonProperty("axes", NullValueHandling = NullValueHandling.Ignore)]
        public Axis[] Axes { get; set; }

        [JsonProperty("data", NullValueHandling = NullValueHandling.Ignore)]
        public Data[] Data { get; set; }

        [JsonProperty("encode", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, EncodeEntry> Encode { get; set; }

        [JsonProperty("layout", NullValueHandling = NullValueHandling.Ignore)]
        public Layout Layout { get; set; }

        [JsonProperty("legends", NullValueHandling = NullValueHandling.Ignore)]
        public Legend[] Legends { get; set; }

        [JsonProperty("marks", NullValueHandling = NullValueHandling.Ignore)]
        public Mark[] Marks { get; set; }

        [JsonProperty("projections", NullValueHandling = NullValueHandling.Ignore)]
        public Projection[] Projections { get; set; }

        [JsonProperty("scales", NullValueHandling = NullValueHandling.Ignore)]
        public Scale[] Scales { get; set; }

        [JsonProperty("signals", NullValueHandling = NullValueHandling.Ignore)]
        public Signal[] Signals { get; set; }

        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public Title? Title { get; set; }

        [JsonProperty("usermeta", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, object> Usermeta { get; set; }

        [JsonProperty("$schema", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Schema { get; set; }

        [JsonProperty("autosize", NullValueHandling = NullValueHandling.Ignore)]
        public Autosize? Autosize { get; set; }

        [JsonProperty("background", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Background { get; set; }

        [JsonProperty("config", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, object> Config { get; set; }

        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        [JsonProperty("height", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Height { get; set; }

        [JsonProperty("padding", NullValueHandling = NullValueHandling.Ignore)]
        public Padding? Padding { get; set; }

        [JsonProperty("style", NullValueHandling = NullValueHandling.Ignore)]
        public Style? Style { get; set; }

        [JsonProperty("width", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Width { get; set; }
    }

    public partial class AutosizeSignalRef
    {
        [JsonProperty("contains", NullValueHandling = NullValueHandling.Ignore)]
        public Contains? Contains { get; set; }

        [JsonProperty("resize", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Resize { get; set; }

        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public AutosizeEnum? Type { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }
    }

    public partial class Axis
    {
        [JsonProperty("aria", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Aria { get; set; }

        [JsonProperty("bandPosition", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? BandPosition { get; set; }

        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        [JsonProperty("domain", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Domain { get; set; }

        [JsonProperty("domainCap", NullValueHandling = NullValueHandling.Ignore)]
        public DomainCapUnion? DomainCap { get; set; }

        [JsonProperty("domainColor")]
        public DomainColorUnion? DomainColor { get; set; }

        [JsonProperty("domainDash", NullValueHandling = NullValueHandling.Ignore)]
        public DomainDashUnion? DomainDash { get; set; }

        [JsonProperty("domainDashOffset", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? DomainDashOffset { get; set; }

        [JsonProperty("domainOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? DomainOpacity { get; set; }

        [JsonProperty("domainWidth", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? DomainWidth { get; set; }

        [JsonProperty("encode", NullValueHandling = NullValueHandling.Ignore)]
        public AxeEncode Encode { get; set; }

        [JsonProperty("format", NullValueHandling = NullValueHandling.Ignore)]
        public AxeFormat? Format { get; set; }

        [JsonProperty("formatType", NullValueHandling = NullValueHandling.Ignore)]
        public FormatTypeUnion? FormatType { get; set; }

        [JsonProperty("grid", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Grid { get; set; }

        [JsonProperty("gridCap", NullValueHandling = NullValueHandling.Ignore)]
        public DomainCapUnion? GridCap { get; set; }

        [JsonProperty("gridColor")]
        public DomainColorUnion? GridColor { get; set; }

        [JsonProperty("gridDash", NullValueHandling = NullValueHandling.Ignore)]
        public DomainDashUnion? GridDash { get; set; }

        [JsonProperty("gridDashOffset", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? GridDashOffset { get; set; }

        [JsonProperty("gridOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? GridOpacity { get; set; }

        [JsonProperty("gridScale", NullValueHandling = NullValueHandling.Ignore)]
        public string GridScale { get; set; }

        [JsonProperty("gridWidth", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? GridWidth { get; set; }

        [JsonProperty("labelAlign", NullValueHandling = NullValueHandling.Ignore)]
        public LabelAlignUnion? LabelAlign { get; set; }

        [JsonProperty("labelAngle", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? LabelAngle { get; set; }

        [JsonProperty("labelBaseline", NullValueHandling = NullValueHandling.Ignore)]
        public LabelBaselineUnion? LabelBaseline { get; set; }

        [JsonProperty("labelBound", NullValueHandling = NullValueHandling.Ignore)]
        public LabelBound? LabelBound { get; set; }

        [JsonProperty("labelColor")]
        public DomainColorUnion? LabelColor { get; set; }

        [JsonProperty("labelFlush", NullValueHandling = NullValueHandling.Ignore)]
        public LabelBound? LabelFlush { get; set; }

        [JsonProperty("labelFlushOffset", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? LabelFlushOffset { get; set; }

        [JsonProperty("labelFont", NullValueHandling = NullValueHandling.Ignore)]
        public DomainCapUnion? LabelFont { get; set; }

        [JsonProperty("labelFontSize", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? LabelFontSize { get; set; }

        [JsonProperty("labelFontStyle", NullValueHandling = NullValueHandling.Ignore)]
        public DomainCapUnion? LabelFontStyle { get; set; }

        [JsonProperty("labelFontWeight")]
        public LabelFontWeightUnion? LabelFontWeight { get; set; }

        [JsonProperty("labelLimit", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? LabelLimit { get; set; }

        [JsonProperty("labelLineHeight", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? LabelLineHeight { get; set; }

        [JsonProperty("labelOffset", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? LabelOffset { get; set; }

        [JsonProperty("labelOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? LabelOpacity { get; set; }

        [JsonProperty("labelOverlap", NullValueHandling = NullValueHandling.Ignore)]
        public LabelOverlap? LabelOverlap { get; set; }

        [JsonProperty("labelPadding", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? LabelPadding { get; set; }

        [JsonProperty("labels", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Labels { get; set; }

        [JsonProperty("labelSeparation", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? LabelSeparation { get; set; }

        [JsonProperty("maxExtent", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? MaxExtent { get; set; }

        [JsonProperty("minExtent", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? MinExtent { get; set; }

        [JsonProperty("offset", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? Offset { get; set; }

        [JsonProperty("orient")]
        public AxeOrient Orient { get; set; }

        [JsonProperty("position", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? Position { get; set; }

        [JsonProperty("scale")]
        public string Scale { get; set; }

        [JsonProperty("tickBand", NullValueHandling = NullValueHandling.Ignore)]
        public TickBand? TickBand { get; set; }

        [JsonProperty("tickCap", NullValueHandling = NullValueHandling.Ignore)]
        public DomainCapUnion? TickCap { get; set; }

        [JsonProperty("tickColor")]
        public DomainColorUnion? TickColor { get; set; }

        [JsonProperty("tickCount", NullValueHandling = NullValueHandling.Ignore)]
        public TickCount? TickCount { get; set; }

        [JsonProperty("tickDash", NullValueHandling = NullValueHandling.Ignore)]
        public DomainDashUnion? TickDash { get; set; }

        [JsonProperty("tickDashOffset", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? TickDashOffset { get; set; }

        [JsonProperty("tickExtra", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? TickExtra { get; set; }

        [JsonProperty("tickMinStep", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? TickMinStep { get; set; }

        [JsonProperty("tickOffset", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? TickOffset { get; set; }

        [JsonProperty("tickOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? TickOpacity { get; set; }

        [JsonProperty("tickRound", NullValueHandling = NullValueHandling.Ignore)]
        public TickRoundUnion? TickRound { get; set; }

        [JsonProperty("ticks", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Ticks { get; set; }

        [JsonProperty("tickSize", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? TickSize { get; set; }

        [JsonProperty("tickWidth", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? TickWidth { get; set; }

        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public TextOrSignal? Title { get; set; }

        [JsonProperty("titleAlign", NullValueHandling = NullValueHandling.Ignore)]
        public LabelAlignUnion? TitleAlign { get; set; }

        [JsonProperty("titleAnchor")]
        public TitleAnchorUnion? TitleAnchor { get; set; }

        [JsonProperty("titleAngle", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? TitleAngle { get; set; }

        [JsonProperty("titleBaseline", NullValueHandling = NullValueHandling.Ignore)]
        public LabelBaselineUnion? TitleBaseline { get; set; }

        [JsonProperty("titleColor")]
        public DomainColorUnion? TitleColor { get; set; }

        [JsonProperty("titleFont", NullValueHandling = NullValueHandling.Ignore)]
        public DomainCapUnion? TitleFont { get; set; }

        [JsonProperty("titleFontSize", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? TitleFontSize { get; set; }

        [JsonProperty("titleFontStyle", NullValueHandling = NullValueHandling.Ignore)]
        public DomainCapUnion? TitleFontStyle { get; set; }

        [JsonProperty("titleFontWeight")]
        public LabelFontWeightUnion? TitleFontWeight { get; set; }

        [JsonProperty("titleLimit", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? TitleLimit { get; set; }

        [JsonProperty("titleLineHeight", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? TitleLineHeight { get; set; }

        [JsonProperty("titleOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? TitleOpacity { get; set; }

        [JsonProperty("titlePadding", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? TitlePadding { get; set; }

        [JsonProperty("titleX", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? TitleX { get; set; }

        [JsonProperty("titleY", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? TitleY { get; set; }

        [JsonProperty("translate", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? Translate { get; set; }

        [JsonProperty("values", NullValueHandling = NullValueHandling.Ignore)]
        public ArrayOrSignal? Values { get; set; }

        [JsonProperty("zindex", NullValueHandling = NullValueHandling.Ignore)]
        public double? Zindex { get; set; }
    }

    public partial class BandPositionClass
    {
        [JsonProperty("band", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Band { get; set; }

        [JsonProperty("exponent", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? Exponent { get; set; }

        [JsonProperty("extra", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Extra { get; set; }

        [JsonProperty("mult", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? Mult { get; set; }

        [JsonProperty("offset", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? Offset { get; set; }

        [JsonProperty("round", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Round { get; set; }

        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }
    }

    public partial class BandPositionElement
    {
        [JsonProperty("test", NullValueHandling = NullValueHandling.Ignore)]
        public string Test { get; set; }

        [JsonProperty("band", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Band { get; set; }

        [JsonProperty("exponent", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? Exponent { get; set; }

        [JsonProperty("extra", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Extra { get; set; }

        [JsonProperty("mult", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? Mult { get; set; }

        [JsonProperty("offset", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? Offset { get; set; }

        [JsonProperty("round", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Round { get; set; }

        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }
    }

    public partial class PurpleSignalRef
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("datum", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Datum { get; set; }

        [JsonProperty("group", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Group { get; set; }

        [JsonProperty("level", NullValueHandling = NullValueHandling.Ignore)]
        public double? Level { get; set; }

        [JsonProperty("parent", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Parent { get; set; }
    }

    public partial class DomainCapElement
    {
        [JsonProperty("test", NullValueHandling = NullValueHandling.Ignore)]
        public string Test { get; set; }

        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class DomainCapClass
    {
        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class BaseColorValue
    {
        [JsonProperty("test", NullValueHandling = NullValueHandling.Ignore)]
        public string Test { get; set; }

        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }

        [JsonProperty("count", NullValueHandling = NullValueHandling.Ignore)]
        public double? Count { get; set; }

        [JsonProperty("gradient", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Gradient { get; set; }

        [JsonProperty("start", NullValueHandling = NullValueHandling.Ignore)]
        public double[] Start { get; set; }

        [JsonProperty("stop", NullValueHandling = NullValueHandling.Ignore)]
        public double[] Stop { get; set; }

        [JsonProperty("color", NullValueHandling = NullValueHandling.Ignore)]
        public Color Color { get; set; }
    }

    public partial class Color
    {
        [JsonProperty("b", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? B { get; set; }

        [JsonProperty("g", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? G { get; set; }

        [JsonProperty("r", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? R { get; set; }

        [JsonProperty("h", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? H { get; set; }

        [JsonProperty("l", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? L { get; set; }

        [JsonProperty("s", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? S { get; set; }

        [JsonProperty("a", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? A { get; set; }

        [JsonProperty("c", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? C { get; set; }
    }

    public partial class PurpleBaseColorValue
    {
        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }

        [JsonProperty("count", NullValueHandling = NullValueHandling.Ignore)]
        public double? Count { get; set; }

        [JsonProperty("gradient", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Gradient { get; set; }

        [JsonProperty("start", NullValueHandling = NullValueHandling.Ignore)]
        public double[] Start { get; set; }

        [JsonProperty("stop", NullValueHandling = NullValueHandling.Ignore)]
        public double[] Stop { get; set; }

        [JsonProperty("color", NullValueHandling = NullValueHandling.Ignore)]
        public Color Color { get; set; }
    }

    public partial class ArrayValueElement
    {
        [JsonProperty("test", NullValueHandling = NullValueHandling.Ignore)]
        public string Test { get; set; }

        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class DomainDashClass
    {
        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class AxeEncode
    {
        [JsonProperty("axis", NullValueHandling = NullValueHandling.Ignore)]
        public GuideEncode Axis { get; set; }

        [JsonProperty("domain", NullValueHandling = NullValueHandling.Ignore)]
        public GuideEncode Domain { get; set; }

        [JsonProperty("grid", NullValueHandling = NullValueHandling.Ignore)]
        public GuideEncode Grid { get; set; }

        [JsonProperty("labels", NullValueHandling = NullValueHandling.Ignore)]
        public GuideEncode Labels { get; set; }

        [JsonProperty("ticks", NullValueHandling = NullValueHandling.Ignore)]
        public GuideEncode Ticks { get; set; }

        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public GuideEncode Title { get; set; }
    }

    public partial class GuideEncode
    {
        [JsonProperty("interactive", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Interactive { get; set; }

        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        [JsonProperty("style", NullValueHandling = NullValueHandling.Ignore)]
        public Style? Style { get; set; }
    }

    public partial class FluffySignalRef
    {
        [JsonProperty("date", NullValueHandling = NullValueHandling.Ignore)]
        public string Date { get; set; }

        [JsonProperty("day", NullValueHandling = NullValueHandling.Ignore)]
        public string Day { get; set; }

        [JsonProperty("hours", NullValueHandling = NullValueHandling.Ignore)]
        public string Hours { get; set; }

        [JsonProperty("milliseconds", NullValueHandling = NullValueHandling.Ignore)]
        public string Milliseconds { get; set; }

        [JsonProperty("minutes", NullValueHandling = NullValueHandling.Ignore)]
        public string Minutes { get; set; }

        [JsonProperty("month", NullValueHandling = NullValueHandling.Ignore)]
        public string Month { get; set; }

        [JsonProperty("quarter", NullValueHandling = NullValueHandling.Ignore)]
        public string Quarter { get; set; }

        [JsonProperty("seconds", NullValueHandling = NullValueHandling.Ignore)]
        public string Seconds { get; set; }

        [JsonProperty("week", NullValueHandling = NullValueHandling.Ignore)]
        public string Week { get; set; }

        [JsonProperty("year", NullValueHandling = NullValueHandling.Ignore)]
        public string Year { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }
    }

    public partial class FormatTypeSignalRef
    {
        [JsonProperty("signal")]
        public string Signal { get; set; }
    }

    public partial class LabelAlignElement
    {
        [JsonProperty("test", NullValueHandling = NullValueHandling.Ignore)]
        public string Test { get; set; }

        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class LabelAlignClass
    {
        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class LabelBaselineElement
    {
        [JsonProperty("test", NullValueHandling = NullValueHandling.Ignore)]
        public string Test { get; set; }

        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class LabelBaselineClass
    {
        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class LabelFontWeightElement
    {
        [JsonProperty("test", NullValueHandling = NullValueHandling.Ignore)]
        public string Test { get; set; }

        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class LabelFontWeightClass
    {
        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class TickCountSignalRef
    {
        [JsonProperty("interval", NullValueHandling = NullValueHandling.Ignore)]
        public Interval? Interval { get; set; }

        [JsonProperty("step", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Step { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }
    }

    public partial class TickRoundElement
    {
        [JsonProperty("test", NullValueHandling = NullValueHandling.Ignore)]
        public string Test { get; set; }

        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class TickRoundClass
    {
        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class TitleAnchorElement
    {
        [JsonProperty("test", NullValueHandling = NullValueHandling.Ignore)]
        public string Test { get; set; }

        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class AnchorValue
    {
        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class Data
    {
        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("on", NullValueHandling = NullValueHandling.Ignore)]
        public OnTrigger[] On { get; set; }

        [JsonProperty("transform", NullValueHandling = NullValueHandling.Ignore)]
        public Transform[] Transform { get; set; }

        [JsonProperty("source", NullValueHandling = NullValueHandling.Ignore)]
        public Style? Source { get; set; }

        [JsonProperty("async", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Async { get; set; }

        [JsonProperty("format", NullValueHandling = NullValueHandling.Ignore)]
        public SignalRef Format { get; set; }

        [JsonProperty("url", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Url { get; set; }

        [JsonProperty("values")]
        public object Values { get; set; }
    }

    public partial class SignalRef
    {
        [JsonProperty("parse", NullValueHandling = NullValueHandling.Ignore)]
        public ParseUnion? Parse { get; set; }

        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Type { get; set; }

        [JsonProperty("copy", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Copy { get; set; }

        [JsonProperty("property", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Property { get; set; }

        [JsonProperty("header", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Header { get; set; }

        [JsonProperty("delimiter", NullValueHandling = NullValueHandling.Ignore)]
        public string Delimiter { get; set; }

        [JsonProperty("feature", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Feature { get; set; }

        [JsonProperty("filter")]
        public Filter? Filter { get; set; }

        [JsonProperty("mesh", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Mesh { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }
    }

    public partial class ParseSignalRef
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }
    }

    public partial class OnTrigger
    {
        [JsonProperty("insert", NullValueHandling = NullValueHandling.Ignore)]
        public string Insert { get; set; }

        [JsonProperty("modify", NullValueHandling = NullValueHandling.Ignore)]
        public string Modify { get; set; }

        [JsonProperty("remove", NullValueHandling = NullValueHandling.Ignore)]
        public Remove? Remove { get; set; }

        [JsonProperty("toggle", NullValueHandling = NullValueHandling.Ignore)]
        public string Toggle { get; set; }

        [JsonProperty("trigger")]
        public string Trigger { get; set; }

        [JsonProperty("values", NullValueHandling = NullValueHandling.Ignore)]
        public string Values { get; set; }
    }

    public partial class Transform
    {
        [JsonProperty("fields", NullValueHandling = NullValueHandling.Ignore)]
        public FieldsUnion? Fields { get; set; }

        [JsonProperty("query", NullValueHandling = NullValueHandling.Ignore)]
        public ArrayOrSignal? Query { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("type")]
        public TransformType Type { get; set; }

        [JsonProperty("filter")]
        public object Filter { get; set; }

        [JsonProperty("ignore", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Ignore { get; set; }

        [JsonProperty("as")]
        public TransformAs? As { get; set; }

        [JsonProperty("orient", NullValueHandling = NullValueHandling.Ignore)]
        public TransformOrient? Orient { get; set; }

        [JsonProperty("require", NullValueHandling = NullValueHandling.Ignore)]
        public FormatTypeSignalRef Require { get; set; }

        [JsonProperty("shape", NullValueHandling = NullValueHandling.Ignore)]
        public ShapeUnion? Shape { get; set; }

        [JsonProperty("sourceX", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? SourceX { get; set; }

        [JsonProperty("sourceY", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? SourceY { get; set; }

        [JsonProperty("targetX", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? TargetX { get; set; }

        [JsonProperty("targetY", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? TargetY { get; set; }

        [JsonProperty("endAngle", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? EndAngle { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? Field { get; set; }

        [JsonProperty("sort", NullValueHandling = NullValueHandling.Ignore)]
        public SortUnion? Sort { get; set; }

        [JsonProperty("startAngle", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? StartAngle { get; set; }

        [JsonProperty("groupby", NullValueHandling = NullValueHandling.Ignore)]
        public GroupbyUnion? Groupby { get; set; }

        [JsonProperty("offset", NullValueHandling = NullValueHandling.Ignore)]
        public TransformOffset? Offset { get; set; }

        [JsonProperty("alpha", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Alpha { get; set; }

        [JsonProperty("alphaMin", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? AlphaMin { get; set; }

        [JsonProperty("alphaTarget", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? AlphaTarget { get; set; }

        [JsonProperty("forces", NullValueHandling = NullValueHandling.Ignore)]
        public ForceElement[] Forces { get; set; }

        [JsonProperty("iterations", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Iterations { get; set; }

        [JsonProperty("restart", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Restart { get; set; }

        [JsonProperty("static", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Static { get; set; }

        [JsonProperty("velocityDecay", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? VelocityDecay { get; set; }

        [JsonProperty("bandwidth", NullValueHandling = NullValueHandling.Ignore)]
        public StepsUnion? Bandwidth { get; set; }

        [JsonProperty("cellSize", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? CellSize { get; set; }

        [JsonProperty("count", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Count { get; set; }

        [JsonProperty("nice", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Nice { get; set; }

        [JsonProperty("size", NullValueHandling = NullValueHandling.Ignore)]
        public StepsUnion? Size { get; set; }

        [JsonProperty("smooth", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Smooth { get; set; }

        [JsonProperty("thresholds", NullValueHandling = NullValueHandling.Ignore)]
        public CenterElement? Thresholds { get; set; }

        [JsonProperty("values", NullValueHandling = NullValueHandling.Ignore)]
        public ValuesUnion? Values { get; set; }

        [JsonProperty("weight", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? Weight { get; set; }

        [JsonProperty("x", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? X { get; set; }

        [JsonProperty("y", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? Y { get; set; }

        [JsonProperty("geojson", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? Geojson { get; set; }

        [JsonProperty("pointRadius", NullValueHandling = NullValueHandling.Ignore)]
        public Radius? PointRadius { get; set; }

        [JsonProperty("projection", NullValueHandling = NullValueHandling.Ignore)]
        public string Projection { get; set; }

        [JsonProperty("extent", NullValueHandling = NullValueHandling.Ignore)]
        public ArrayOrSignal? Extent { get; set; }

        [JsonProperty("extentMajor", NullValueHandling = NullValueHandling.Ignore)]
        public ArrayOrSignal? ExtentMajor { get; set; }

        [JsonProperty("extentMinor", NullValueHandling = NullValueHandling.Ignore)]
        public ArrayOrSignal? ExtentMinor { get; set; }

        [JsonProperty("precision", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Precision { get; set; }

        [JsonProperty("step", NullValueHandling = NullValueHandling.Ignore)]
        public StepsUnion? Step { get; set; }

        [JsonProperty("stepMajor", NullValueHandling = NullValueHandling.Ignore)]
        public CenterElement? StepMajor { get; set; }

        [JsonProperty("stepMinor", NullValueHandling = NullValueHandling.Ignore)]
        public CenterElement? StepMinor { get; set; }

        [JsonProperty("color", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? Color { get; set; }

        [JsonProperty("opacity", NullValueHandling = NullValueHandling.Ignore)]
        public Radius? Opacity { get; set; }

        [JsonProperty("resolve", NullValueHandling = NullValueHandling.Ignore)]
        public ResolveUnion? Resolve { get; set; }

        [JsonProperty("levels", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Levels { get; set; }

        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Radius? Scale { get; set; }

        [JsonProperty("translate", NullValueHandling = NullValueHandling.Ignore)]
        public Translate? Translate { get; set; }

        [JsonProperty("zero", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Zero { get; set; }

        [JsonProperty("counts", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Counts { get; set; }

        [JsonProperty("generate", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Generate { get; set; }

        [JsonProperty("keys", NullValueHandling = NullValueHandling.Ignore)]
        public GroupbyUnion? Keys { get; set; }

        [JsonProperty("padding")]
        public TransformPadding? Padding { get; set; }

        [JsonProperty("radius", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? Radius { get; set; }

        [JsonProperty("round", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Round { get; set; }

        [JsonProperty("key", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? Key { get; set; }

        [JsonProperty("parentKey", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? ParentKey { get; set; }

        [JsonProperty("method", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Method { get; set; }

        [JsonProperty("nodeSize", NullValueHandling = NullValueHandling.Ignore)]
        public CenterElement? NodeSize { get; set; }

        [JsonProperty("separation", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Separation { get; set; }

        [JsonProperty("paddingBottom", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? PaddingBottom { get; set; }

        [JsonProperty("paddingInner", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? PaddingInner { get; set; }

        [JsonProperty("paddingLeft", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? PaddingLeft { get; set; }

        [JsonProperty("paddingOuter", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? PaddingOuter { get; set; }

        [JsonProperty("paddingRight", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? PaddingRight { get; set; }

        [JsonProperty("paddingTop", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? PaddingTop { get; set; }

        [JsonProperty("ratio", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Ratio { get; set; }

        [JsonProperty("anchor", NullValueHandling = NullValueHandling.Ignore)]
        public AnchorUnion? Anchor { get; set; }

        [JsonProperty("avoidBaseMark", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? AvoidBaseMark { get; set; }

        [JsonProperty("avoidMarks", NullValueHandling = NullValueHandling.Ignore)]
        public AvoidMarks? AvoidMarks { get; set; }

        [JsonProperty("lineAnchor", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? LineAnchor { get; set; }

        [JsonProperty("markIndex", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? MarkIndex { get; set; }

        [JsonProperty("order", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Order { get; set; }

        [JsonProperty("params", NullValueHandling = NullValueHandling.Ignore)]
        public ParamsUnion? Params { get; set; }

        [JsonProperty("aggregate_params", NullValueHandling = NullValueHandling.Ignore)]
        public Params? AggregateParams { get; set; }

        [JsonProperty("cross", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Cross { get; set; }

        [JsonProperty("drop", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Drop { get; set; }

        [JsonProperty("ops", NullValueHandling = NullValueHandling.Ignore)]
        public Ops? Ops { get; set; }

        [JsonProperty("base", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Base { get; set; }

        [JsonProperty("divide", NullValueHandling = NullValueHandling.Ignore)]
        public CenterElement? Divide { get; set; }

        [JsonProperty("interval", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Interval { get; set; }

        [JsonProperty("maxbins", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Maxbins { get; set; }

        [JsonProperty("minstep", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Minstep { get; set; }

        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Name { get; set; }

        [JsonProperty("span", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Span { get; set; }

        [JsonProperty("steps", NullValueHandling = NullValueHandling.Ignore)]
        public StepsUnion? Steps { get; set; }

        [JsonProperty("case", NullValueHandling = NullValueHandling.Ignore)]
        public CaseUnion? Case { get; set; }

        [JsonProperty("pattern", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Pattern { get; set; }

        [JsonProperty("stopwords", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Stopwords { get; set; }

        [JsonProperty("distribution", NullValueHandling = NullValueHandling.Ignore)]
        public Distribution Distribution { get; set; }

        [JsonProperty("maxsteps", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Maxsteps { get; set; }

        [JsonProperty("minsteps", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Minsteps { get; set; }

        [JsonProperty("expr", NullValueHandling = NullValueHandling.Ignore)]
        public string Expr { get; set; }

        [JsonProperty("index", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Index { get; set; }

        [JsonProperty("initonly", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Initonly { get; set; }

        [JsonProperty("keyvals", NullValueHandling = NullValueHandling.Ignore)]
        public ArrayOrSignal? Keyvals { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("cumulative", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Cumulative { get; set; }

        [JsonProperty("default")]
        public object Default { get; set; }

        [JsonProperty("from", NullValueHandling = NullValueHandling.Ignore)]
        public string From { get; set; }

        [JsonProperty("limit", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Limit { get; set; }

        [JsonProperty("op", NullValueHandling = NullValueHandling.Ignore)]
        public TransformOp? Op { get; set; }

        [JsonProperty("probs", NullValueHandling = NullValueHandling.Ignore)]
        public CenterElement? Probs { get; set; }

        [JsonProperty("start", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Start { get; set; }

        [JsonProperty("stop", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Stop { get; set; }

        [JsonProperty("timezone", NullValueHandling = NullValueHandling.Ignore)]
        public TimezoneUnion? Timezone { get; set; }

        [JsonProperty("units", NullValueHandling = NullValueHandling.Ignore)]
        public Units? Units { get; set; }

        [JsonProperty("frame", NullValueHandling = NullValueHandling.Ignore)]
        public Params? Frame { get; set; }

        [JsonProperty("ignorePeers", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? IgnorePeers { get; set; }

        [JsonProperty("font", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? Font { get; set; }

        [JsonProperty("fontSize", NullValueHandling = NullValueHandling.Ignore)]
        public Radius? FontSize { get; set; }

        [JsonProperty("fontSizeRange")]
        public FontSizeRange? FontSizeRange { get; set; }

        [JsonProperty("fontStyle", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? FontStyle { get; set; }

        [JsonProperty("fontWeight", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? FontWeight { get; set; }

        [JsonProperty("rotate", NullValueHandling = NullValueHandling.Ignore)]
        public Radius? Rotate { get; set; }

        [JsonProperty("spiral", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Spiral { get; set; }

        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? Text { get; set; }
    }

    public partial class ColorSignalRef
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("as", NullValueHandling = NullValueHandling.Ignore)]
        public string As { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public string Field { get; set; }

        [JsonProperty("expr", NullValueHandling = NullValueHandling.Ignore)]
        public string Expr { get; set; }
    }

    public partial class Distribution
    {
        [JsonProperty("function")]
        public Function Function { get; set; }

        [JsonProperty("mean", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Mean { get; set; }

        [JsonProperty("stdev", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Stdev { get; set; }

        [JsonProperty("max", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Max { get; set; }

        [JsonProperty("min", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Min { get; set; }

        [JsonProperty("bandwidth", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Bandwidth { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? Field { get; set; }

        [JsonProperty("from", NullValueHandling = NullValueHandling.Ignore)]
        public string From { get; set; }

        [JsonProperty("distributions", NullValueHandling = NullValueHandling.Ignore)]
        public ArrayOrSignal? Distributions { get; set; }

        [JsonProperty("weights", NullValueHandling = NullValueHandling.Ignore)]
        public CenterElement? Weights { get; set; }
    }

    public partial class TentacledSignalRef
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("as", NullValueHandling = NullValueHandling.Ignore)]
        public string As { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public string Field { get; set; }

        [JsonProperty("expr", NullValueHandling = NullValueHandling.Ignore)]
        public string Expr { get; set; }
    }

    public partial class FontSizeSignalRef
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("as", NullValueHandling = NullValueHandling.Ignore)]
        public string As { get; set; }

        [JsonProperty("expr", NullValueHandling = NullValueHandling.Ignore)]
        public string Expr { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public string Field { get; set; }
    }

    public partial class ForceElement
    {
        [JsonProperty("force")]
        public ForceEnum Force { get; set; }

        [JsonProperty("x", NullValueHandling = NullValueHandling.Ignore)]
        public XUnion? X { get; set; }

        [JsonProperty("y", NullValueHandling = NullValueHandling.Ignore)]
        public XUnion? Y { get; set; }

        [JsonProperty("iterations", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Iterations { get; set; }

        [JsonProperty("radius", NullValueHandling = NullValueHandling.Ignore)]
        public Radius? Radius { get; set; }

        [JsonProperty("strength", NullValueHandling = NullValueHandling.Ignore)]
        public StrengthUnion? Strength { get; set; }

        [JsonProperty("distanceMax", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? DistanceMax { get; set; }

        [JsonProperty("distanceMin", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? DistanceMin { get; set; }

        [JsonProperty("theta", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Theta { get; set; }

        [JsonProperty("distance", NullValueHandling = NullValueHandling.Ignore)]
        public Radius? Distance { get; set; }

        [JsonProperty("id", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? Id { get; set; }

        [JsonProperty("links", NullValueHandling = NullValueHandling.Ignore)]
        public string Links { get; set; }
    }

    public partial class StrengthSignalRef
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("as", NullValueHandling = NullValueHandling.Ignore)]
        public string As { get; set; }

        [JsonProperty("expr", NullValueHandling = NullValueHandling.Ignore)]
        public string Expr { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public string Field { get; set; }
    }

    public partial class StickySignalRef
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("as", NullValueHandling = NullValueHandling.Ignore)]
        public string As { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public string Field { get; set; }

        [JsonProperty("expr", NullValueHandling = NullValueHandling.Ignore)]
        public string Expr { get; set; }
    }

    public partial class PaddingExpr
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("as", NullValueHandling = NullValueHandling.Ignore)]
        public string As { get; set; }

        [JsonProperty("expr", NullValueHandling = NullValueHandling.Ignore)]
        public string Expr { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public string Field { get; set; }
    }

    public partial class CompareClass
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public CompareField? Field { get; set; }

        [JsonProperty("order", NullValueHandling = NullValueHandling.Ignore)]
        public OrderUnion? Order { get; set; }
    }

    public partial class IndigoSignalRef
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("as", NullValueHandling = NullValueHandling.Ignore)]
        public string As { get; set; }

        [JsonProperty("expr", NullValueHandling = NullValueHandling.Ignore)]
        public string Expr { get; set; }
    }

    public partial class IndecentSignalRef
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("as", NullValueHandling = NullValueHandling.Ignore)]
        public string As { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public string Field { get; set; }

        [JsonProperty("expr", NullValueHandling = NullValueHandling.Ignore)]
        public string Expr { get; set; }
    }

    public partial class EncodeEntry
    {
        [JsonProperty("align", NullValueHandling = NullValueHandling.Ignore)]
        public AlignValue? Align { get; set; }

        [JsonProperty("angle", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? Angle { get; set; }

        [JsonProperty("aria", NullValueHandling = NullValueHandling.Ignore)]
        public BooleanValue? Aria { get; set; }

        [JsonProperty("ariaRole", NullValueHandling = NullValueHandling.Ignore)]
        public StringValue? AriaRole { get; set; }

        [JsonProperty("ariaRoleDescription", NullValueHandling = NullValueHandling.Ignore)]
        public StringValue? AriaRoleDescription { get; set; }

        [JsonProperty("aspect", NullValueHandling = NullValueHandling.Ignore)]
        public BooleanValue? Aspect { get; set; }

        [JsonProperty("baseline", NullValueHandling = NullValueHandling.Ignore)]
        public BaselineValue? Baseline { get; set; }

        [JsonProperty("blend", NullValueHandling = NullValueHandling.Ignore)]
        public BlendValue? Blend { get; set; }

        [JsonProperty("clip", NullValueHandling = NullValueHandling.Ignore)]
        public BooleanValue? Clip { get; set; }

        [JsonProperty("cornerRadius", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? CornerRadius { get; set; }

        [JsonProperty("cornerRadiusBottomLeft", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? CornerRadiusBottomLeft { get; set; }

        [JsonProperty("cornerRadiusBottomRight", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? CornerRadiusBottomRight { get; set; }

        [JsonProperty("cornerRadiusTopLeft", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? CornerRadiusTopLeft { get; set; }

        [JsonProperty("cornerRadiusTopRight", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? CornerRadiusTopRight { get; set; }

        [JsonProperty("cursor", NullValueHandling = NullValueHandling.Ignore)]
        public StringValue? Cursor { get; set; }

        [JsonProperty("defined", NullValueHandling = NullValueHandling.Ignore)]
        public BooleanValue? Defined { get; set; }

        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public StringValue? Description { get; set; }

        [JsonProperty("dir", NullValueHandling = NullValueHandling.Ignore)]
        public StringValue? Dir { get; set; }

        [JsonProperty("dx", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? Dx { get; set; }

        [JsonProperty("dy", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? Dy { get; set; }

        [JsonProperty("ellipsis", NullValueHandling = NullValueHandling.Ignore)]
        public StringValue? Ellipsis { get; set; }

        [JsonProperty("endAngle", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? EndAngle { get; set; }

        [JsonProperty("fill", NullValueHandling = NullValueHandling.Ignore)]
        public ColorValue? Fill { get; set; }

        [JsonProperty("fillOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? FillOpacity { get; set; }

        [JsonProperty("font", NullValueHandling = NullValueHandling.Ignore)]
        public StringValue? Font { get; set; }

        [JsonProperty("fontSize", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? FontSize { get; set; }

        [JsonProperty("fontStyle", NullValueHandling = NullValueHandling.Ignore)]
        public StringValue? FontStyle { get; set; }

        [JsonProperty("fontWeight", NullValueHandling = NullValueHandling.Ignore)]
        public FontWeightValue? FontWeight { get; set; }

        [JsonProperty("height", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? Height { get; set; }

        [JsonProperty("innerRadius", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? InnerRadius { get; set; }

        [JsonProperty("interpolate", NullValueHandling = NullValueHandling.Ignore)]
        public StringValue? Interpolate { get; set; }

        [JsonProperty("limit", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? Limit { get; set; }

        [JsonProperty("lineBreak", NullValueHandling = NullValueHandling.Ignore)]
        public StringValue? LineBreak { get; set; }

        [JsonProperty("lineHeight", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? LineHeight { get; set; }

        [JsonProperty("opacity", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? Opacity { get; set; }

        [JsonProperty("orient", NullValueHandling = NullValueHandling.Ignore)]
        public DirectionValue? Orient { get; set; }

        [JsonProperty("outerRadius", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? OuterRadius { get; set; }

        [JsonProperty("padAngle", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? PadAngle { get; set; }

        [JsonProperty("path", NullValueHandling = NullValueHandling.Ignore)]
        public StringValue? Path { get; set; }

        [JsonProperty("radius", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? Radius { get; set; }

        [JsonProperty("scaleX", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? ScaleX { get; set; }

        [JsonProperty("scaleY", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? ScaleY { get; set; }

        [JsonProperty("shape", NullValueHandling = NullValueHandling.Ignore)]
        public StringValue? Shape { get; set; }

        [JsonProperty("size", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? Size { get; set; }

        [JsonProperty("smooth", NullValueHandling = NullValueHandling.Ignore)]
        public BooleanValue? Smooth { get; set; }

        [JsonProperty("startAngle", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? StartAngle { get; set; }

        [JsonProperty("stroke", NullValueHandling = NullValueHandling.Ignore)]
        public ColorValue? Stroke { get; set; }

        [JsonProperty("strokeCap", NullValueHandling = NullValueHandling.Ignore)]
        public StrokeCapValue? StrokeCap { get; set; }

        [JsonProperty("strokeDash", NullValueHandling = NullValueHandling.Ignore)]
        public ArrayValue? StrokeDash { get; set; }

        [JsonProperty("strokeDashOffset", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? StrokeDashOffset { get; set; }

        [JsonProperty("strokeForeground", NullValueHandling = NullValueHandling.Ignore)]
        public BooleanValue? StrokeForeground { get; set; }

        [JsonProperty("strokeJoin", NullValueHandling = NullValueHandling.Ignore)]
        public StrokeJoinValue? StrokeJoin { get; set; }

        [JsonProperty("strokeMiterLimit", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? StrokeMiterLimit { get; set; }

        [JsonProperty("strokeOffset", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? StrokeOffset { get; set; }

        [JsonProperty("strokeOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? StrokeOpacity { get; set; }

        [JsonProperty("strokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? StrokeWidth { get; set; }

        [JsonProperty("tension", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? Tension { get; set; }

        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public TextValue? Text { get; set; }

        [JsonProperty("theta", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? Theta { get; set; }

        [JsonProperty("tooltip", NullValueHandling = NullValueHandling.Ignore)]
        public AnyValue? Tooltip { get; set; }

        [JsonProperty("url", NullValueHandling = NullValueHandling.Ignore)]
        public StringValue? Url { get; set; }

        [JsonProperty("width", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? Width { get; set; }

        [JsonProperty("x", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? X { get; set; }

        [JsonProperty("x2", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? X2 { get; set; }

        [JsonProperty("xc", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? Xc { get; set; }

        [JsonProperty("y", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? Y { get; set; }

        [JsonProperty("y2", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? Y2 { get; set; }

        [JsonProperty("yc", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? Yc { get; set; }

        [JsonProperty("zindex", NullValueHandling = NullValueHandling.Ignore)]
        public NumberValue? Zindex { get; set; }
    }

    public partial class BlendValueElement
    {
        [JsonProperty("test", NullValueHandling = NullValueHandling.Ignore)]
        public string Test { get; set; }

        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class BlendValueClass
    {
        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class FluffyBaseColorValue
    {
        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }

        [JsonProperty("count", NullValueHandling = NullValueHandling.Ignore)]
        public double? Count { get; set; }

        [JsonProperty("gradient", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Gradient { get; set; }

        [JsonProperty("start", NullValueHandling = NullValueHandling.Ignore)]
        public double[] Start { get; set; }

        [JsonProperty("stop", NullValueHandling = NullValueHandling.Ignore)]
        public double[] Stop { get; set; }

        [JsonProperty("color", NullValueHandling = NullValueHandling.Ignore)]
        public Color Color { get; set; }
    }

    public partial class DirectionValueElement
    {
        [JsonProperty("test", NullValueHandling = NullValueHandling.Ignore)]
        public string Test { get; set; }

        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class DirectionValueClass
    {
        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class StrokeCapValueElement
    {
        [JsonProperty("test", NullValueHandling = NullValueHandling.Ignore)]
        public string Test { get; set; }

        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class StrokeCapValueClass
    {
        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class StrokeJoinValueElement
    {
        [JsonProperty("test", NullValueHandling = NullValueHandling.Ignore)]
        public string Test { get; set; }

        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class StrokeJoinValueClass
    {
        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class TextValueElement
    {
        [JsonProperty("test", NullValueHandling = NullValueHandling.Ignore)]
        public string Test { get; set; }

        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class TextValueClass
    {
        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class AnyValueElement
    {
        [JsonProperty("test", NullValueHandling = NullValueHandling.Ignore)]
        public string Test { get; set; }

        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class AnyValueClass
    {
        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class Layout
    {
        [JsonProperty("align", NullValueHandling = NullValueHandling.Ignore)]
        public AlignUnion? Align { get; set; }

        [JsonProperty("bounds", NullValueHandling = NullValueHandling.Ignore)]
        public BoundsUnion? Bounds { get; set; }

        [JsonProperty("center", NullValueHandling = NullValueHandling.Ignore)]
        public Center? Center { get; set; }

        [JsonProperty("columns", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Columns { get; set; }

        [JsonProperty("footerBand")]
        public FooterBandUnion? FooterBand { get; set; }

        [JsonProperty("headerBand")]
        public HeaderBandUnion? HeaderBand { get; set; }

        [JsonProperty("offset", NullValueHandling = NullValueHandling.Ignore)]
        public LayoutOffset? Offset { get; set; }

        [JsonProperty("padding", NullValueHandling = NullValueHandling.Ignore)]
        public PaddingUnion? Padding { get; set; }

        [JsonProperty("titleAnchor", NullValueHandling = NullValueHandling.Ignore)]
        public TitleAnchor? TitleAnchor { get; set; }

        [JsonProperty("titleBand")]
        public TitleBandUnion? TitleBand { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }
    }

    public partial class HilariousSignalRef
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("column", NullValueHandling = NullValueHandling.Ignore)]
        public GridAlignUnion? Column { get; set; }

        [JsonProperty("row", NullValueHandling = NullValueHandling.Ignore)]
        public GridAlignUnion? Row { get; set; }
    }

    public partial class AmbitiousSignalRef
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("column", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Column { get; set; }

        [JsonProperty("row", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Row { get; set; }
    }

    public partial class FooterBandSignalRef
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("column", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Column { get; set; }

        [JsonProperty("row", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Row { get; set; }
    }

    public partial class HeaderBandSignalRef
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("column", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Column { get; set; }

        [JsonProperty("row", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Row { get; set; }
    }

    public partial class CunningSignalRef
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("columnFooter", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? ColumnFooter { get; set; }

        [JsonProperty("columnHeader", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? ColumnHeader { get; set; }

        [JsonProperty("columnTitle", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? ColumnTitle { get; set; }

        [JsonProperty("rowFooter", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? RowFooter { get; set; }

        [JsonProperty("rowHeader", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? RowHeader { get; set; }

        [JsonProperty("rowTitle", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? RowTitle { get; set; }
    }

    public partial class MagentaSignalRef
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("column", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Column { get; set; }

        [JsonProperty("row", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Row { get; set; }
    }

    public partial class TitleAnchorSignalRef
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("column", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleColumn? Column { get; set; }

        [JsonProperty("row", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleColumn? Row { get; set; }
    }

    public partial class TitleBandSignalRef
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("column", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Column { get; set; }

        [JsonProperty("row", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Row { get; set; }
    }

    public partial class Legend
    {
        [JsonProperty("aria", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Aria { get; set; }

        [JsonProperty("clipHeight", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? ClipHeight { get; set; }

        [JsonProperty("columnPadding", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? ColumnPadding { get; set; }

        [JsonProperty("columns", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Columns { get; set; }

        [JsonProperty("cornerRadius", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? CornerRadius { get; set; }

        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        [JsonProperty("direction", NullValueHandling = NullValueHandling.Ignore)]
        public Direction? Direction { get; set; }

        [JsonProperty("encode", NullValueHandling = NullValueHandling.Ignore)]
        public LegendEncode Encode { get; set; }

        [JsonProperty("fill", NullValueHandling = NullValueHandling.Ignore)]
        public string Fill { get; set; }

        [JsonProperty("fillColor")]
        public DomainColorUnion? FillColor { get; set; }

        [JsonProperty("format", NullValueHandling = NullValueHandling.Ignore)]
        public LegendFormat? Format { get; set; }

        [JsonProperty("formatType", NullValueHandling = NullValueHandling.Ignore)]
        public FormatTypeUnion? FormatType { get; set; }

        [JsonProperty("gradientLength", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? GradientLength { get; set; }

        [JsonProperty("gradientOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? GradientOpacity { get; set; }

        [JsonProperty("gradientStrokeColor")]
        public DomainColorUnion? GradientStrokeColor { get; set; }

        [JsonProperty("gradientStrokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? GradientStrokeWidth { get; set; }

        [JsonProperty("gradientThickness", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? GradientThickness { get; set; }

        [JsonProperty("gridAlign", NullValueHandling = NullValueHandling.Ignore)]
        public GridAlignUnion? GridAlign { get; set; }

        [JsonProperty("labelAlign", NullValueHandling = NullValueHandling.Ignore)]
        public LabelAlignUnion? LabelAlign { get; set; }

        [JsonProperty("labelBaseline", NullValueHandling = NullValueHandling.Ignore)]
        public LabelBaselineUnion? LabelBaseline { get; set; }

        [JsonProperty("labelColor")]
        public DomainColorUnion? LabelColor { get; set; }

        [JsonProperty("labelFont", NullValueHandling = NullValueHandling.Ignore)]
        public DomainCapUnion? LabelFont { get; set; }

        [JsonProperty("labelFontSize", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? LabelFontSize { get; set; }

        [JsonProperty("labelFontStyle", NullValueHandling = NullValueHandling.Ignore)]
        public DomainCapUnion? LabelFontStyle { get; set; }

        [JsonProperty("labelFontWeight")]
        public LabelFontWeightUnion? LabelFontWeight { get; set; }

        [JsonProperty("labelLimit", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? LabelLimit { get; set; }

        [JsonProperty("labelOffset", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? LabelOffset { get; set; }

        [JsonProperty("labelOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? LabelOpacity { get; set; }

        [JsonProperty("labelOverlap", NullValueHandling = NullValueHandling.Ignore)]
        public LabelOverlap? LabelOverlap { get; set; }

        [JsonProperty("labelSeparation", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? LabelSeparation { get; set; }

        [JsonProperty("legendX", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? LegendX { get; set; }

        [JsonProperty("legendY", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? LegendY { get; set; }

        [JsonProperty("offset", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? Offset { get; set; }

        [JsonProperty("opacity", NullValueHandling = NullValueHandling.Ignore)]
        public string Opacity { get; set; }

        [JsonProperty("orient", NullValueHandling = NullValueHandling.Ignore)]
        public LegendOrient? Orient { get; set; }

        [JsonProperty("padding", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? Padding { get; set; }

        [JsonProperty("rowPadding", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? RowPadding { get; set; }

        [JsonProperty("shape", NullValueHandling = NullValueHandling.Ignore)]
        public string Shape { get; set; }

        [JsonProperty("size", NullValueHandling = NullValueHandling.Ignore)]
        public string Size { get; set; }

        [JsonProperty("stroke", NullValueHandling = NullValueHandling.Ignore)]
        public string Stroke { get; set; }

        [JsonProperty("strokeColor")]
        public DomainColorUnion? StrokeColor { get; set; }

        [JsonProperty("strokeDash", NullValueHandling = NullValueHandling.Ignore)]
        public string StrokeDash { get; set; }

        [JsonProperty("strokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public string StrokeWidth { get; set; }

        [JsonProperty("symbolDash", NullValueHandling = NullValueHandling.Ignore)]
        public DomainDashUnion? SymbolDash { get; set; }

        [JsonProperty("symbolDashOffset", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? SymbolDashOffset { get; set; }

        [JsonProperty("symbolFillColor")]
        public DomainColorUnion? SymbolFillColor { get; set; }

        [JsonProperty("symbolLimit", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? SymbolLimit { get; set; }

        [JsonProperty("symbolOffset", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? SymbolOffset { get; set; }

        [JsonProperty("symbolOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? SymbolOpacity { get; set; }

        [JsonProperty("symbolSize", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? SymbolSize { get; set; }

        [JsonProperty("symbolStrokeColor")]
        public DomainColorUnion? SymbolStrokeColor { get; set; }

        [JsonProperty("symbolStrokeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? SymbolStrokeWidth { get; set; }

        [JsonProperty("symbolType", NullValueHandling = NullValueHandling.Ignore)]
        public DomainCapUnion? SymbolType { get; set; }

        [JsonProperty("tickCount", NullValueHandling = NullValueHandling.Ignore)]
        public TickCount? TickCount { get; set; }

        [JsonProperty("tickMinStep", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? TickMinStep { get; set; }

        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public TextOrSignal? Title { get; set; }

        [JsonProperty("titleAlign", NullValueHandling = NullValueHandling.Ignore)]
        public LabelAlignUnion? TitleAlign { get; set; }

        [JsonProperty("titleAnchor")]
        public TitleAnchorUnion? TitleAnchor { get; set; }

        [JsonProperty("titleBaseline", NullValueHandling = NullValueHandling.Ignore)]
        public LabelBaselineUnion? TitleBaseline { get; set; }

        [JsonProperty("titleColor")]
        public DomainColorUnion? TitleColor { get; set; }

        [JsonProperty("titleFont", NullValueHandling = NullValueHandling.Ignore)]
        public DomainCapUnion? TitleFont { get; set; }

        [JsonProperty("titleFontSize", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? TitleFontSize { get; set; }

        [JsonProperty("titleFontStyle", NullValueHandling = NullValueHandling.Ignore)]
        public DomainCapUnion? TitleFontStyle { get; set; }

        [JsonProperty("titleFontWeight")]
        public LabelFontWeightUnion? TitleFontWeight { get; set; }

        [JsonProperty("titleLimit", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? TitleLimit { get; set; }

        [JsonProperty("titleLineHeight", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? TitleLineHeight { get; set; }

        [JsonProperty("titleOpacity", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? TitleOpacity { get; set; }

        [JsonProperty("titleOrient", NullValueHandling = NullValueHandling.Ignore)]
        public TitleOrientUnion? TitleOrient { get; set; }

        [JsonProperty("titlePadding", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? TitlePadding { get; set; }

        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public LegendType? Type { get; set; }

        [JsonProperty("values", NullValueHandling = NullValueHandling.Ignore)]
        public ArrayOrSignal? Values { get; set; }

        [JsonProperty("zindex", NullValueHandling = NullValueHandling.Ignore)]
        public double? Zindex { get; set; }
    }

    public partial class LegendEncode
    {
        [JsonProperty("entries", NullValueHandling = NullValueHandling.Ignore)]
        public GuideEncode Entries { get; set; }

        [JsonProperty("gradient", NullValueHandling = NullValueHandling.Ignore)]
        public GuideEncode Gradient { get; set; }

        [JsonProperty("labels", NullValueHandling = NullValueHandling.Ignore)]
        public GuideEncode Labels { get; set; }

        [JsonProperty("legend", NullValueHandling = NullValueHandling.Ignore)]
        public GuideEncode Legend { get; set; }

        [JsonProperty("symbols", NullValueHandling = NullValueHandling.Ignore)]
        public GuideEncode Symbols { get; set; }

        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public GuideEncode Title { get; set; }
    }

    public partial class FriskySignalRef
    {
        [JsonProperty("date", NullValueHandling = NullValueHandling.Ignore)]
        public string Date { get; set; }

        [JsonProperty("day", NullValueHandling = NullValueHandling.Ignore)]
        public string Day { get; set; }

        [JsonProperty("hours", NullValueHandling = NullValueHandling.Ignore)]
        public string Hours { get; set; }

        [JsonProperty("milliseconds", NullValueHandling = NullValueHandling.Ignore)]
        public string Milliseconds { get; set; }

        [JsonProperty("minutes", NullValueHandling = NullValueHandling.Ignore)]
        public string Minutes { get; set; }

        [JsonProperty("month", NullValueHandling = NullValueHandling.Ignore)]
        public string Month { get; set; }

        [JsonProperty("quarter", NullValueHandling = NullValueHandling.Ignore)]
        public string Quarter { get; set; }

        [JsonProperty("seconds", NullValueHandling = NullValueHandling.Ignore)]
        public string Seconds { get; set; }

        [JsonProperty("week", NullValueHandling = NullValueHandling.Ignore)]
        public string Week { get; set; }

        [JsonProperty("year", NullValueHandling = NullValueHandling.Ignore)]
        public string Year { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }
    }

    public partial class TitleOrientElement
    {
        [JsonProperty("test", NullValueHandling = NullValueHandling.Ignore)]
        public string Test { get; set; }

        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class OrientValue
    {
        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Scale { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public Field? Field { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public Band? Range { get; set; }

        [JsonProperty("band")]
        public object Band { get; set; }

        [JsonProperty("offset")]
        public object Offset { get; set; }
    }

    public partial class Mark
    {
        [JsonProperty("from", NullValueHandling = NullValueHandling.Ignore)]
        public From From { get; set; }

        [JsonProperty("type")]
        public string Type { get; set; }

        [JsonProperty("aria", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Aria { get; set; }

        [JsonProperty("clip", NullValueHandling = NullValueHandling.Ignore)]
        public Markclip? Clip { get; set; }

        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        [JsonProperty("encode", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, EncodeEntry> Encode { get; set; }

        [JsonProperty("interactive", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Interactive { get; set; }

        [JsonProperty("key", NullValueHandling = NullValueHandling.Ignore)]
        public string Key { get; set; }

        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        [JsonProperty("on", NullValueHandling = NullValueHandling.Ignore)]
        public OnMarkTrigger[] On { get; set; }

        [JsonProperty("role", NullValueHandling = NullValueHandling.Ignore)]
        public string Role { get; set; }

        [JsonProperty("sort", NullValueHandling = NullValueHandling.Ignore)]
        public Compare Sort { get; set; }

        [JsonProperty("style", NullValueHandling = NullValueHandling.Ignore)]
        public Style? Style { get; set; }

        [JsonProperty("transform", NullValueHandling = NullValueHandling.Ignore)]
        public TransformMark[] Transform { get; set; }

        [JsonProperty("zindex", NullValueHandling = NullValueHandling.Ignore)]
        public double? Zindex { get; set; }

        [JsonProperty("axes", NullValueHandling = NullValueHandling.Ignore)]
        public Axis[] Axes { get; set; }

        [JsonProperty("data", NullValueHandling = NullValueHandling.Ignore)]
        public Data[] Data { get; set; }

        [JsonProperty("layout", NullValueHandling = NullValueHandling.Ignore)]
        public Layout Layout { get; set; }

        [JsonProperty("legends", NullValueHandling = NullValueHandling.Ignore)]
        public Legend[] Legends { get; set; }

        [JsonProperty("marks", NullValueHandling = NullValueHandling.Ignore)]
        public Mark[] Marks { get; set; }

        [JsonProperty("projections", NullValueHandling = NullValueHandling.Ignore)]
        public Projection[] Projections { get; set; }

        [JsonProperty("scales", NullValueHandling = NullValueHandling.Ignore)]
        public Scale[] Scales { get; set; }

        [JsonProperty("signals", NullValueHandling = NullValueHandling.Ignore)]
        public Signal[] Signals { get; set; }

        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public Title? Title { get; set; }

        [JsonProperty("usermeta", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, object> Usermeta { get; set; }
    }

    public partial class MarkclipSignalRef
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("path", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Path { get; set; }

        [JsonProperty("sphere", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Sphere { get; set; }
    }

    public partial class From
    {
        [JsonProperty("data", NullValueHandling = NullValueHandling.Ignore)]
        public string Data { get; set; }

        [JsonProperty("facet", NullValueHandling = NullValueHandling.Ignore)]
        public Facet Facet { get; set; }
    }

    public partial class Facet
    {
        [JsonProperty("data")]
        public string Data { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public string Field { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("aggregate", NullValueHandling = NullValueHandling.Ignore)]
        public Aggregate Aggregate { get; set; }

        [JsonProperty("groupby", NullValueHandling = NullValueHandling.Ignore)]
        public Style? Groupby { get; set; }
    }

    public partial class Aggregate
    {
        [JsonProperty("as", NullValueHandling = NullValueHandling.Ignore)]
        public string[] As { get; set; }

        [JsonProperty("cross", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Cross { get; set; }

        [JsonProperty("fields", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Fields { get; set; }

        [JsonProperty("ops", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Ops { get; set; }
    }

    public partial class OnMarkTrigger
    {
        [JsonProperty("modify", NullValueHandling = NullValueHandling.Ignore)]
        public string Modify { get; set; }

        [JsonProperty("trigger")]
        public string Trigger { get; set; }

        [JsonProperty("values", NullValueHandling = NullValueHandling.Ignore)]
        public string Values { get; set; }
    }

    public partial class Projection
    {
        [JsonProperty("center", NullValueHandling = NullValueHandling.Ignore)]
        public CenterElement? Center { get; set; }

        [JsonProperty("clipAngle", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? ClipAngle { get; set; }

        [JsonProperty("clipExtent", NullValueHandling = NullValueHandling.Ignore)]
        public Extent? ClipExtent { get; set; }

        [JsonProperty("extent", NullValueHandling = NullValueHandling.Ignore)]
        public Extent? Extent { get; set; }

        [JsonProperty("fit", NullValueHandling = NullValueHandling.Ignore)]
        public Fit? Fit { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("parallels", NullValueHandling = NullValueHandling.Ignore)]
        public CenterElement? Parallels { get; set; }

        [JsonProperty("pointRadius", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? PointRadius { get; set; }

        [JsonProperty("precision", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Precision { get; set; }

        [JsonProperty("rotate", NullValueHandling = NullValueHandling.Ignore)]
        public CenterElement? Rotate { get; set; }

        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Scale { get; set; }

        [JsonProperty("size", NullValueHandling = NullValueHandling.Ignore)]
        public CenterElement? Size { get; set; }

        [JsonProperty("translate", NullValueHandling = NullValueHandling.Ignore)]
        public CenterElement? Translate { get; set; }

        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Type { get; set; }
    }

    public partial class Scale
    {
        [JsonProperty("domain", NullValueHandling = NullValueHandling.Ignore)]
        public ScaleData? Domain { get; set; }

        [JsonProperty("domainMax", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? DomainMax { get; set; }

        [JsonProperty("domainMid", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? DomainMid { get; set; }

        [JsonProperty("domainMin", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? DomainMin { get; set; }

        [JsonProperty("domainRaw")]
        public DomainRaw? DomainRaw { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("nice", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleBooleanOrSignal? Nice { get; set; }

        [JsonProperty("reverse", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Reverse { get; set; }

        [JsonProperty("round", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Round { get; set; }

        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public ScaleType? Type { get; set; }

        [JsonProperty("domainImplicit", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? DomainImplicit { get; set; }

        [JsonProperty("interpolate", NullValueHandling = NullValueHandling.Ignore)]
        public ScaleInterpolate? Interpolate { get; set; }

        [JsonProperty("range", NullValueHandling = NullValueHandling.Ignore)]
        public RangeUnion? Range { get; set; }

        [JsonProperty("align", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Align { get; set; }

        [JsonProperty("padding", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Padding { get; set; }

        [JsonProperty("paddingInner", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? PaddingInner { get; set; }

        [JsonProperty("paddingOuter", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? PaddingOuter { get; set; }

        [JsonProperty("zero", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Zero { get; set; }

        [JsonProperty("bins", NullValueHandling = NullValueHandling.Ignore)]
        public ScaleBins? Bins { get; set; }

        [JsonProperty("clamp", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Clamp { get; set; }

        [JsonProperty("base", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Base { get; set; }

        [JsonProperty("exponent", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Exponent { get; set; }

        [JsonProperty("constant", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Constant { get; set; }
    }

    public partial class ScaleBinsSignalRef
    {
        [JsonProperty("start", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Start { get; set; }

        [JsonProperty("step", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Step { get; set; }

        [JsonProperty("stop", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Stop { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }
    }

    public partial class MischievousSignalRef
    {
        [JsonProperty("data", NullValueHandling = NullValueHandling.Ignore)]
        public string Data { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Field { get; set; }

        [JsonProperty("sort", NullValueHandling = NullValueHandling.Ignore)]
        public TentacledSort? Sort { get; set; }

        [JsonProperty("fields", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleStringOrSignal[] Fields { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }
    }

    public partial class BraggadociousSignalRef
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("data", NullValueHandling = NullValueHandling.Ignore)]
        public string Data { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Field { get; set; }
    }

    public partial class PurpleSort
    {
        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Field { get; set; }

        [JsonProperty("op", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Op { get; set; }

        [JsonProperty("order", NullValueHandling = NullValueHandling.Ignore)]
        public SortOrder? Order { get; set; }
    }

    public partial class ScaleInterpolateSignalRef
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("gamma", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Gamma { get; set; }

        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Type { get; set; }
    }

    public partial class SignalRef1
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("interval", NullValueHandling = NullValueHandling.Ignore)]
        public Interval? Interval { get; set; }

        [JsonProperty("step", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Step { get; set; }
    }

    public partial class SignalRef2
    {
        [JsonProperty("count", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Count { get; set; }

        [JsonProperty("extent", NullValueHandling = NullValueHandling.Ignore)]
        public CenterElement? Extent { get; set; }

        [JsonProperty("scheme", NullValueHandling = NullValueHandling.Ignore)]
        public Scheme? Scheme { get; set; }

        [JsonProperty("data", NullValueHandling = NullValueHandling.Ignore)]
        public string Data { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Field { get; set; }

        [JsonProperty("sort", NullValueHandling = NullValueHandling.Ignore)]
        public StickySort? Sort { get; set; }

        [JsonProperty("fields", NullValueHandling = NullValueHandling.Ignore)]
        public FluffyStringOrSignal[] Fields { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("step", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Step { get; set; }
    }

    public partial class SignalRef3
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("data", NullValueHandling = NullValueHandling.Ignore)]
        public string Data { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Field { get; set; }
    }

    public partial class FluffySort
    {
        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Field { get; set; }

        [JsonProperty("op", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Op { get; set; }

        [JsonProperty("order", NullValueHandling = NullValueHandling.Ignore)]
        public SortOrder? Order { get; set; }
    }

    public partial class Signal
    {
        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("on", NullValueHandling = NullValueHandling.Ignore)]
        public OnEvent[] On { get; set; }

        [JsonProperty("push", NullValueHandling = NullValueHandling.Ignore)]
        public Push? Push { get; set; }

        [JsonProperty("bind", NullValueHandling = NullValueHandling.Ignore)]
        public Bind Bind { get; set; }

        [JsonProperty("react", NullValueHandling = NullValueHandling.Ignore)]
        public bool? React { get; set; }

        [JsonProperty("update", NullValueHandling = NullValueHandling.Ignore)]
        public string Update { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }

        [JsonProperty("init", NullValueHandling = NullValueHandling.Ignore)]
        public string Init { get; set; }
    }

    public partial class Bind
    {
        [JsonProperty("debounce", NullValueHandling = NullValueHandling.Ignore)]
        public double? Debounce { get; set; }

        [JsonProperty("element", NullValueHandling = NullValueHandling.Ignore)]
        public string Element { get; set; }

        [JsonProperty("input")]
        public object Input { get; set; }

        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        [JsonProperty("labels", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Labels { get; set; }

        [JsonProperty("options", NullValueHandling = NullValueHandling.Ignore)]
        public object[] Options { get; set; }

        [JsonProperty("max", NullValueHandling = NullValueHandling.Ignore)]
        public double? Max { get; set; }

        [JsonProperty("min", NullValueHandling = NullValueHandling.Ignore)]
        public double? Min { get; set; }

        [JsonProperty("step", NullValueHandling = NullValueHandling.Ignore)]
        public double? Step { get; set; }

        [JsonProperty("event", NullValueHandling = NullValueHandling.Ignore)]
        public string Event { get; set; }
    }

    public partial class OnEvent
    {
        [JsonProperty("events")]
        public EventsUnion Events { get; set; }

        [JsonProperty("force", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Force { get; set; }

        [JsonProperty("encode", NullValueHandling = NullValueHandling.Ignore)]
        public string Encode { get; set; }

        [JsonProperty("update", NullValueHandling = NullValueHandling.Ignore)]
        public Update? Update { get; set; }
    }

    public partial class Listener
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public string Scale { get; set; }

        [JsonProperty("between", NullValueHandling = NullValueHandling.Ignore)]
        public Stream[] Between { get; set; }

        [JsonProperty("consume", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Consume { get; set; }

        [JsonProperty("debounce", NullValueHandling = NullValueHandling.Ignore)]
        public double? Debounce { get; set; }

        [JsonProperty("filter", NullValueHandling = NullValueHandling.Ignore)]
        public Style? Filter { get; set; }

        [JsonProperty("markname", NullValueHandling = NullValueHandling.Ignore)]
        public string Markname { get; set; }

        [JsonProperty("marktype", NullValueHandling = NullValueHandling.Ignore)]
        public string Marktype { get; set; }

        [JsonProperty("throttle", NullValueHandling = NullValueHandling.Ignore)]
        public double? Throttle { get; set; }

        [JsonProperty("source", NullValueHandling = NullValueHandling.Ignore)]
        public string Source { get; set; }

        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public string Type { get; set; }

        [JsonProperty("stream", NullValueHandling = NullValueHandling.Ignore)]
        public Stream Stream { get; set; }

        [JsonProperty("merge", NullValueHandling = NullValueHandling.Ignore)]
        public Stream[] Merge { get; set; }
    }

    public partial class Stream
    {
        [JsonProperty("between", NullValueHandling = NullValueHandling.Ignore)]
        public Stream[] Between { get; set; }

        [JsonProperty("consume", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Consume { get; set; }

        [JsonProperty("debounce", NullValueHandling = NullValueHandling.Ignore)]
        public double? Debounce { get; set; }

        [JsonProperty("filter", NullValueHandling = NullValueHandling.Ignore)]
        public Style? Filter { get; set; }

        [JsonProperty("markname", NullValueHandling = NullValueHandling.Ignore)]
        public string Markname { get; set; }

        [JsonProperty("marktype", NullValueHandling = NullValueHandling.Ignore)]
        public string Marktype { get; set; }

        [JsonProperty("throttle", NullValueHandling = NullValueHandling.Ignore)]
        public double? Throttle { get; set; }

        [JsonProperty("source", NullValueHandling = NullValueHandling.Ignore)]
        public string Source { get; set; }

        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public string Type { get; set; }

        [JsonProperty("stream", NullValueHandling = NullValueHandling.Ignore)]
        public Stream StreamStream { get; set; }

        [JsonProperty("merge", NullValueHandling = NullValueHandling.Ignore)]
        public Stream[] Merge { get; set; }
    }

    public partial class StreamClass
    {
        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public string Scale { get; set; }

        [JsonProperty("between", NullValueHandling = NullValueHandling.Ignore)]
        public Stream[] Between { get; set; }

        [JsonProperty("consume", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Consume { get; set; }

        [JsonProperty("debounce", NullValueHandling = NullValueHandling.Ignore)]
        public double? Debounce { get; set; }

        [JsonProperty("filter", NullValueHandling = NullValueHandling.Ignore)]
        public Style? Filter { get; set; }

        [JsonProperty("markname", NullValueHandling = NullValueHandling.Ignore)]
        public string Markname { get; set; }

        [JsonProperty("marktype", NullValueHandling = NullValueHandling.Ignore)]
        public string Marktype { get; set; }

        [JsonProperty("throttle", NullValueHandling = NullValueHandling.Ignore)]
        public double? Throttle { get; set; }

        [JsonProperty("source", NullValueHandling = NullValueHandling.Ignore)]
        public string Source { get; set; }

        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public string Type { get; set; }

        [JsonProperty("stream", NullValueHandling = NullValueHandling.Ignore)]
        public Stream Stream { get; set; }

        [JsonProperty("merge", NullValueHandling = NullValueHandling.Ignore)]
        public Stream[] Merge { get; set; }
    }

    public partial class Expr
    {
        [JsonProperty("as", NullValueHandling = NullValueHandling.Ignore)]
        public string As { get; set; }

        [JsonProperty("expr", NullValueHandling = NullValueHandling.Ignore)]
        public string ExprExpr { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }
    }

    public partial class Compare
    {
        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public CompareField? Field { get; set; }

        [JsonProperty("order", NullValueHandling = NullValueHandling.Ignore)]
        public OrderUnion? Order { get; set; }
    }

    public partial class TitleClass
    {
        [JsonProperty("align", NullValueHandling = NullValueHandling.Ignore)]
        public LabelAlignUnion? Align { get; set; }

        [JsonProperty("anchor")]
        public TitleAnchorUnion? Anchor { get; set; }

        [JsonProperty("angle", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? Angle { get; set; }

        [JsonProperty("aria", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Aria { get; set; }

        [JsonProperty("baseline", NullValueHandling = NullValueHandling.Ignore)]
        public LabelBaselineUnion? Baseline { get; set; }

        [JsonProperty("color")]
        public DomainColorUnion? Color { get; set; }

        [JsonProperty("dx", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? Dx { get; set; }

        [JsonProperty("dy", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? Dy { get; set; }

        [JsonProperty("encode", NullValueHandling = NullValueHandling.Ignore)]
        public TitleEncode Encode { get; set; }

        [JsonProperty("font", NullValueHandling = NullValueHandling.Ignore)]
        public DomainCapUnion? Font { get; set; }

        [JsonProperty("fontSize", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? FontSize { get; set; }

        [JsonProperty("fontStyle", NullValueHandling = NullValueHandling.Ignore)]
        public DomainCapUnion? FontStyle { get; set; }

        [JsonProperty("fontWeight")]
        public LabelFontWeightUnion? FontWeight { get; set; }

        [JsonProperty("frame", NullValueHandling = NullValueHandling.Ignore)]
        public FrameUnion? Frame { get; set; }

        [JsonProperty("interactive", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Interactive { get; set; }

        [JsonProperty("limit", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? Limit { get; set; }

        [JsonProperty("lineHeight", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? LineHeight { get; set; }

        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        [JsonProperty("offset", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? Offset { get; set; }

        [JsonProperty("orient", NullValueHandling = NullValueHandling.Ignore)]
        public TitleOrient? Orient { get; set; }

        [JsonProperty("style", NullValueHandling = NullValueHandling.Ignore)]
        public Style? Style { get; set; }

        [JsonProperty("subtitle", NullValueHandling = NullValueHandling.Ignore)]
        public TextOrSignal? Subtitle { get; set; }

        [JsonProperty("subtitleColor")]
        public DomainColorUnion? SubtitleColor { get; set; }

        [JsonProperty("subtitleFont", NullValueHandling = NullValueHandling.Ignore)]
        public DomainCapUnion? SubtitleFont { get; set; }

        [JsonProperty("subtitleFontSize", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? SubtitleFontSize { get; set; }

        [JsonProperty("subtitleFontStyle", NullValueHandling = NullValueHandling.Ignore)]
        public DomainCapUnion? SubtitleFontStyle { get; set; }

        [JsonProperty("subtitleFontWeight")]
        public LabelFontWeightUnion? SubtitleFontWeight { get; set; }

        [JsonProperty("subtitleLineHeight", NullValueHandling = NullValueHandling.Ignore)]
        public BandPositionUnion? SubtitleLineHeight { get; set; }

        [JsonProperty("subtitlePadding", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? SubtitlePadding { get; set; }

        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public TextOrSignal? Text { get; set; }

        [JsonProperty("zindex", NullValueHandling = NullValueHandling.Ignore)]
        public double? Zindex { get; set; }
    }

    public partial class TitleEncode
    {
        [JsonProperty("group", NullValueHandling = NullValueHandling.Ignore)]
        public GuideEncode Group { get; set; }

        [JsonProperty("subtitle", NullValueHandling = NullValueHandling.Ignore)]
        public GuideEncode Subtitle { get; set; }

        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public GuideEncode Title { get; set; }
    }

    public partial class TransformMark
    {
        [JsonProperty("fields", NullValueHandling = NullValueHandling.Ignore)]
        public FieldsUnion? Fields { get; set; }

        [JsonProperty("query", NullValueHandling = NullValueHandling.Ignore)]
        public ArrayOrSignal? Query { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }

        [JsonProperty("type")]
        public TransformMarkType Type { get; set; }

        [JsonProperty("filter")]
        public object Filter { get; set; }

        [JsonProperty("ignore", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Ignore { get; set; }

        [JsonProperty("as", NullValueHandling = NullValueHandling.Ignore)]
        public TransformMarkAs? As { get; set; }

        [JsonProperty("orient", NullValueHandling = NullValueHandling.Ignore)]
        public TransformOrient? Orient { get; set; }

        [JsonProperty("require", NullValueHandling = NullValueHandling.Ignore)]
        public FormatTypeSignalRef Require { get; set; }

        [JsonProperty("shape", NullValueHandling = NullValueHandling.Ignore)]
        public ShapeUnion? Shape { get; set; }

        [JsonProperty("sourceX", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? SourceX { get; set; }

        [JsonProperty("sourceY", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? SourceY { get; set; }

        [JsonProperty("targetX", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? TargetX { get; set; }

        [JsonProperty("targetY", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? TargetY { get; set; }

        [JsonProperty("endAngle", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? EndAngle { get; set; }

        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? Field { get; set; }

        [JsonProperty("sort", NullValueHandling = NullValueHandling.Ignore)]
        public SortUnion? Sort { get; set; }

        [JsonProperty("startAngle", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? StartAngle { get; set; }

        [JsonProperty("groupby", NullValueHandling = NullValueHandling.Ignore)]
        public GroupbyUnion? Groupby { get; set; }

        [JsonProperty("offset", NullValueHandling = NullValueHandling.Ignore)]
        public TransformOffset? Offset { get; set; }

        [JsonProperty("alpha", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Alpha { get; set; }

        [JsonProperty("alphaMin", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? AlphaMin { get; set; }

        [JsonProperty("alphaTarget", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? AlphaTarget { get; set; }

        [JsonProperty("forces", NullValueHandling = NullValueHandling.Ignore)]
        public ForceElement[] Forces { get; set; }

        [JsonProperty("iterations", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Iterations { get; set; }

        [JsonProperty("restart", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Restart { get; set; }

        [JsonProperty("static", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Static { get; set; }

        [JsonProperty("velocityDecay", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? VelocityDecay { get; set; }

        [JsonProperty("geojson", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? Geojson { get; set; }

        [JsonProperty("pointRadius", NullValueHandling = NullValueHandling.Ignore)]
        public Radius? PointRadius { get; set; }

        [JsonProperty("projection", NullValueHandling = NullValueHandling.Ignore)]
        public string Projection { get; set; }

        [JsonProperty("color", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? Color { get; set; }

        [JsonProperty("opacity", NullValueHandling = NullValueHandling.Ignore)]
        public Radius? Opacity { get; set; }

        [JsonProperty("resolve", NullValueHandling = NullValueHandling.Ignore)]
        public ResolveUnion? Resolve { get; set; }

        [JsonProperty("padding")]
        public TransformPadding? Padding { get; set; }

        [JsonProperty("radius", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? Radius { get; set; }

        [JsonProperty("size", NullValueHandling = NullValueHandling.Ignore)]
        public StepsUnion? Size { get; set; }

        [JsonProperty("round", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Round { get; set; }

        [JsonProperty("key", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? Key { get; set; }

        [JsonProperty("parentKey", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? ParentKey { get; set; }

        [JsonProperty("method", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Method { get; set; }

        [JsonProperty("nodeSize", NullValueHandling = NullValueHandling.Ignore)]
        public CenterElement? NodeSize { get; set; }

        [JsonProperty("separation", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Separation { get; set; }

        [JsonProperty("paddingBottom", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? PaddingBottom { get; set; }

        [JsonProperty("paddingInner", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? PaddingInner { get; set; }

        [JsonProperty("paddingLeft", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? PaddingLeft { get; set; }

        [JsonProperty("paddingOuter", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? PaddingOuter { get; set; }

        [JsonProperty("paddingRight", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? PaddingRight { get; set; }

        [JsonProperty("paddingTop", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? PaddingTop { get; set; }

        [JsonProperty("ratio", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Ratio { get; set; }

        [JsonProperty("anchor", NullValueHandling = NullValueHandling.Ignore)]
        public AnchorUnion? Anchor { get; set; }

        [JsonProperty("avoidBaseMark", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? AvoidBaseMark { get; set; }

        [JsonProperty("avoidMarks", NullValueHandling = NullValueHandling.Ignore)]
        public AvoidMarks? AvoidMarks { get; set; }

        [JsonProperty("lineAnchor", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? LineAnchor { get; set; }

        [JsonProperty("markIndex", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? MarkIndex { get; set; }

        [JsonProperty("base", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Base { get; set; }

        [JsonProperty("divide", NullValueHandling = NullValueHandling.Ignore)]
        public CenterElement? Divide { get; set; }

        [JsonProperty("extent", NullValueHandling = NullValueHandling.Ignore)]
        public ArrayOrSignal? Extent { get; set; }

        [JsonProperty("interval", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Interval { get; set; }

        [JsonProperty("maxbins", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Maxbins { get; set; }

        [JsonProperty("minstep", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Minstep { get; set; }

        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Name { get; set; }

        [JsonProperty("nice", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Nice { get; set; }

        [JsonProperty("span", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Span { get; set; }

        [JsonProperty("step", NullValueHandling = NullValueHandling.Ignore)]
        public HeightElement? Step { get; set; }

        [JsonProperty("steps", NullValueHandling = NullValueHandling.Ignore)]
        public CenterElement? Steps { get; set; }

        [JsonProperty("smooth", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Smooth { get; set; }

        [JsonProperty("expr", NullValueHandling = NullValueHandling.Ignore)]
        public string Expr { get; set; }

        [JsonProperty("initonly", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? Initonly { get; set; }

        [JsonProperty("ops", NullValueHandling = NullValueHandling.Ignore)]
        public Ops? Ops { get; set; }

        [JsonProperty("default")]
        public object Default { get; set; }

        [JsonProperty("from", NullValueHandling = NullValueHandling.Ignore)]
        public string From { get; set; }

        [JsonProperty("values", NullValueHandling = NullValueHandling.Ignore)]
        public GroupbyUnion? Values { get; set; }

        [JsonProperty("timezone", NullValueHandling = NullValueHandling.Ignore)]
        public TimezoneUnion? Timezone { get; set; }

        [JsonProperty("units", NullValueHandling = NullValueHandling.Ignore)]
        public Units? Units { get; set; }

        [JsonProperty("aggregate_params", NullValueHandling = NullValueHandling.Ignore)]
        public Params? AggregateParams { get; set; }

        [JsonProperty("frame", NullValueHandling = NullValueHandling.Ignore)]
        public Params? Frame { get; set; }

        [JsonProperty("ignorePeers", NullValueHandling = NullValueHandling.Ignore)]
        public TickExtraUnion? IgnorePeers { get; set; }

        [JsonProperty("params", NullValueHandling = NullValueHandling.Ignore)]
        public Params? Params { get; set; }

        [JsonProperty("x", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? X { get; set; }

        [JsonProperty("y", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? Y { get; set; }

        [JsonProperty("font", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? Font { get; set; }

        [JsonProperty("fontSize", NullValueHandling = NullValueHandling.Ignore)]
        public Radius? FontSize { get; set; }

        [JsonProperty("fontSizeRange")]
        public FontSizeRange? FontSizeRange { get; set; }

        [JsonProperty("fontStyle", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? FontStyle { get; set; }

        [JsonProperty("fontWeight", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? FontWeight { get; set; }

        [JsonProperty("rotate", NullValueHandling = NullValueHandling.Ignore)]
        public Radius? Rotate { get; set; }

        [JsonProperty("spiral", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundElement? Spiral { get; set; }

        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public ColorElement? Text { get; set; }
    }

    public partial class SignalRef4
    {
        [JsonProperty("bottom", NullValueHandling = NullValueHandling.Ignore)]
        public double? Bottom { get; set; }

        [JsonProperty("left", NullValueHandling = NullValueHandling.Ignore)]
        public double? Left { get; set; }

        [JsonProperty("right", NullValueHandling = NullValueHandling.Ignore)]
        public double? Right { get; set; }

        [JsonProperty("top", NullValueHandling = NullValueHandling.Ignore)]
        public double? Top { get; set; }

        [JsonProperty("signal", NullValueHandling = NullValueHandling.Ignore)]
        public string Signal { get; set; }
    }

    public enum AutosizeEnum { Fit, FitX, FitY, None, Pad };

    public enum Contains { Content, Padding };

    public enum FormatTypeEnum { Number, Time, Utc };

    public enum LabelAlignEnum { Center, Left, Right };

    public enum Baseline { Alphabetic, Bottom, LineBottom, LineTop, Middle, Top };

    public enum FontWeight { Bold, Bolder, Lighter, Normal, The100, The200, The300, The400, The500, The600, The700, The800, The900 };

    public enum LabelOverlapEnum { Greedy, Parity };

    public enum TitleOrientEnum { Bottom, Left, Right, Top };

    public enum TickBandEnum { Center, Extent };

    public enum TickCountEnum { Day, Hour, Millisecond, Minute, Month, Second, Week, Year };

    public enum Anchor { End, Middle, Start };

    public enum Filter { Exterior, Interior };

    public enum ParseEnum { Auto };

    public enum CaseEnum { Lower, Mixed, Upper };

    public enum Function { Kde, Lognormal, Mixture, Normal, Uniform };

    public enum ForceEnum { Center, Collide, Link, Nbody, X, Y };

    public enum OffsetEnum { Center, Normalize, Zero };

    public enum PurpleOp { Argmax, Argmin, Average, Ci0, Ci1, Count, Distinct, Exponential, Exponentialb, Max, Mean, Median, Min, Missing, Product, Q1, Q3, Stderr, Stdev, Stdevp, Sum, Valid, Values, Variance, Variancep };

    public enum FluffyOp { Argmax, Argmin, Average, Ci0, Ci1, Count, CumeDist, DenseRank, Distinct, Exponential, Exponentialb, FirstValue, Lag, LastValue, Lead, Max, Mean, Median, Min, Missing, NextValue, NthValue, Ntile, PercentRank, PrevValue, Product, Q1, Q3, Rank, RowNumber, Stderr, Stdev, Stdevp, Sum, Valid, Values, Variance, Variancep };

    public enum PurpleOrient { Horizontal, Radial, Vertical };

    public enum ResolveEnum { Independent, Shared };

    public enum ShapeEnum { Arc, Curve, Diagonal, Line, Orthogonal };

    public enum OrderEnum { Ascending, Descending };

    public enum TimezoneEnum { Local, Utc };

    public enum TransformType { Aggregate, Bin, Collect, Contour, Countpattern, Cross, Crossfilter, Density, Dotbin, Extent, Filter, Flatten, Fold, Force, Formula, Geojson, Geopath, Geopoint, Geoshape, Graticule, Heatmap, Identifier, Impute, Isocontour, Joinaggregate, Kde, Kde2D, Label, Linkpath, Loess, Lookup, Nest, Pack, Partition, Pie, Pivot, Project, Quantile, Regression, Resolvefilter, Sample, Sequence, Stack, Stratify, Timeunit, Tree, Treelinks, Treemap, Voronoi, Window, Wordcloud };

    public enum UnitEnum { Date, Day, Dayofyear, Hours, Milliseconds, Minutes, Month, Quarter, Seconds, Week, Year };

    public enum AlignEnum { All, Each, None };

    public enum BoundsEnum { Flush, Full };

    public enum TitleAnchorEnum { End, Start };

    public enum Direction { Horizontal, Vertical };

    public enum FluffyOrient { Bottom, BottomLeft, BottomRight, Left, None, Right, Top, TopLeft, TopRight };

    public enum LegendType { Gradient, Symbol };

    public enum RangeEnum { Category, Diverging, Heatmap, Height, Ordinal, Ramp, Symbol, Width };

    public enum ScaleType { Band, BinOrdinal, Identity, Linear, Log, Ordinal, Point, Pow, Quantile, Quantize, Sequential, Sqrt, Symlog, Threshold, Time, Utc };

    public enum Push { Outer };

    public enum Frame { Bounds, Group };

    public enum TentacledOrient { Bottom, Left, None, Right, Top };

    public enum TransformMarkType { Bin, Collect, Crossfilter, Dotbin, Extent, Force, Formula, Geojson, Geopath, Geopoint, Geoshape, Heatmap, Identifier, Joinaggregate, Label, Linkpath, Lookup, Pack, Partition, Pie, Resolvefilter, Sample, Stack, Stratify, Timeunit, Tree, Treemap, Voronoi, Window, Wordcloud };

    public partial struct Autosize
    {
        public AutosizeSignalRef AutosizeSignalRef;
        public AutosizeEnum? Enum;

        public static implicit operator Autosize(AutosizeSignalRef AutosizeSignalRef) => new Autosize { AutosizeSignalRef = AutosizeSignalRef };
        public static implicit operator Autosize(AutosizeEnum Enum) => new Autosize { Enum = Enum };
    }

    public partial struct BandPositionUnion
    {
        public BandPositionClass BandPositionClass;
        public BandPositionElement[] BandPositionElementArray;
        public double? Double;

        public static implicit operator BandPositionUnion(BandPositionClass BandPositionClass) => new BandPositionUnion { BandPositionClass = BandPositionClass };
        public static implicit operator BandPositionUnion(BandPositionElement[] BandPositionElementArray) => new BandPositionUnion { BandPositionElementArray = BandPositionElementArray };
        public static implicit operator BandPositionUnion(double Double) => new BandPositionUnion { Double = Double };
    }

    public partial struct Band
    {
        public bool? Bool;
        public double? Double;

        public static implicit operator Band(bool Bool) => new Band { Bool = Bool };
        public static implicit operator Band(double Double) => new Band { Double = Double };
    }

    public partial struct Field
    {
        public PurpleSignalRef PurpleSignalRef;
        public string String;

        public static implicit operator Field(PurpleSignalRef PurpleSignalRef) => new Field { PurpleSignalRef = PurpleSignalRef };
        public static implicit operator Field(string String) => new Field { String = String };
    }

    public partial struct DomainCapUnion
    {
        public DomainCapClass DomainCapClass;
        public DomainCapElement[] DomainCapElementArray;
        public string String;

        public static implicit operator DomainCapUnion(DomainCapClass DomainCapClass) => new DomainCapUnion { DomainCapClass = DomainCapClass };
        public static implicit operator DomainCapUnion(DomainCapElement[] DomainCapElementArray) => new DomainCapUnion { DomainCapElementArray = DomainCapElementArray };
        public static implicit operator DomainCapUnion(string String) => new DomainCapUnion { String = String };
    }

    public partial struct NumberValue
    {
        public BandPositionClass BandPositionClass;
        public BandPositionElement[] BandPositionElementArray;

        public static implicit operator NumberValue(BandPositionClass BandPositionClass) => new NumberValue { BandPositionClass = BandPositionClass };
        public static implicit operator NumberValue(BandPositionElement[] BandPositionElementArray) => new NumberValue { BandPositionElementArray = BandPositionElementArray };
    }

    public partial struct DomainColorUnion
    {
        public BaseColorValue[] BaseColorValueArray;
        public PurpleBaseColorValue PurpleBaseColorValue;
        public string String;

        public static implicit operator DomainColorUnion(BaseColorValue[] BaseColorValueArray) => new DomainColorUnion { BaseColorValueArray = BaseColorValueArray };
        public static implicit operator DomainColorUnion(PurpleBaseColorValue PurpleBaseColorValue) => new DomainColorUnion { PurpleBaseColorValue = PurpleBaseColorValue };
        public static implicit operator DomainColorUnion(string String) => new DomainColorUnion { String = String };
        public bool IsNull => BaseColorValueArray == null && PurpleBaseColorValue == null && String == null;
    }

    public partial struct Dash
    {
        public ArrayValueElement ArrayValueElement;
        public double? Double;

        public static implicit operator Dash(ArrayValueElement ArrayValueElement) => new Dash { ArrayValueElement = ArrayValueElement };
        public static implicit operator Dash(double Double) => new Dash { Double = Double };
    }

    public partial struct DomainDashUnion
    {
        public Dash[] AnythingArray;
        public DomainDashClass DomainDashClass;

        public static implicit operator DomainDashUnion(Dash[] AnythingArray) => new DomainDashUnion { AnythingArray = AnythingArray };
        public static implicit operator DomainDashUnion(DomainDashClass DomainDashClass) => new DomainDashUnion { DomainDashClass = DomainDashClass };
    }

    public partial struct Style
    {
        public string String;
        public string[] StringArray;

        public static implicit operator Style(string String) => new Style { String = String };
        public static implicit operator Style(string[] StringArray) => new Style { StringArray = StringArray };
    }

    public partial struct AxeFormat
    {
        public FluffySignalRef FluffySignalRef;
        public string String;

        public static implicit operator AxeFormat(FluffySignalRef FluffySignalRef) => new AxeFormat { FluffySignalRef = FluffySignalRef };
        public static implicit operator AxeFormat(string String) => new AxeFormat { String = String };
    }

    public partial struct FormatTypeUnion
    {
        public FormatTypeEnum? Enum;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator FormatTypeUnion(FormatTypeEnum Enum) => new FormatTypeUnion { Enum = Enum };
        public static implicit operator FormatTypeUnion(FormatTypeSignalRef FormatTypeSignalRef) => new FormatTypeUnion { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct LabelAlignUnion
    {
        public LabelAlignEnum? Enum;
        public LabelAlignClass LabelAlignClass;
        public LabelAlignElement[] LabelAlignElementArray;

        public static implicit operator LabelAlignUnion(LabelAlignEnum Enum) => new LabelAlignUnion { Enum = Enum };
        public static implicit operator LabelAlignUnion(LabelAlignClass LabelAlignClass) => new LabelAlignUnion { LabelAlignClass = LabelAlignClass };
        public static implicit operator LabelAlignUnion(LabelAlignElement[] LabelAlignElementArray) => new LabelAlignUnion { LabelAlignElementArray = LabelAlignElementArray };
    }

    public partial struct LabelBaselineUnion
    {
        public Baseline? Enum;
        public LabelBaselineClass LabelBaselineClass;
        public LabelBaselineElement[] LabelBaselineElementArray;

        public static implicit operator LabelBaselineUnion(Baseline Enum) => new LabelBaselineUnion { Enum = Enum };
        public static implicit operator LabelBaselineUnion(LabelBaselineClass LabelBaselineClass) => new LabelBaselineUnion { LabelBaselineClass = LabelBaselineClass };
        public static implicit operator LabelBaselineUnion(LabelBaselineElement[] LabelBaselineElementArray) => new LabelBaselineUnion { LabelBaselineElementArray = LabelBaselineElementArray };
    }

    public partial struct LabelBound
    {
        public bool? Bool;
        public double? Double;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator LabelBound(bool Bool) => new LabelBound { Bool = Bool };
        public static implicit operator LabelBound(double Double) => new LabelBound { Double = Double };
        public static implicit operator LabelBound(FormatTypeSignalRef FormatTypeSignalRef) => new LabelBound { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct HeightElement
    {
        public double? Double;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator HeightElement(double Double) => new HeightElement { Double = Double };
        public static implicit operator HeightElement(FormatTypeSignalRef FormatTypeSignalRef) => new HeightElement { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct LabelFontWeightUnion
    {
        public double? Double;
        public FontWeight? Enum;
        public long? Integer;
        public LabelFontWeightClass LabelFontWeightClass;
        public LabelFontWeightElement[] LabelFontWeightElementArray;

        public static implicit operator LabelFontWeightUnion(double Double) => new LabelFontWeightUnion { Double = Double };
        public static implicit operator LabelFontWeightUnion(FontWeight Enum) => new LabelFontWeightUnion { Enum = Enum };
        public static implicit operator LabelFontWeightUnion(long Integer) => new LabelFontWeightUnion { Integer = Integer };
        public static implicit operator LabelFontWeightUnion(LabelFontWeightClass LabelFontWeightClass) => new LabelFontWeightUnion { LabelFontWeightClass = LabelFontWeightClass };
        public static implicit operator LabelFontWeightUnion(LabelFontWeightElement[] LabelFontWeightElementArray) => new LabelFontWeightUnion { LabelFontWeightElementArray = LabelFontWeightElementArray };
        public bool IsNull => LabelFontWeightElementArray == null && LabelFontWeightClass == null && Double == null && Integer == null && Enum == null;
    }

    public partial struct LabelOverlap
    {
        public bool? Bool;
        public LabelOverlapEnum? Enum;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator LabelOverlap(bool Bool) => new LabelOverlap { Bool = Bool };
        public static implicit operator LabelOverlap(LabelOverlapEnum Enum) => new LabelOverlap { Enum = Enum };
        public static implicit operator LabelOverlap(FormatTypeSignalRef FormatTypeSignalRef) => new LabelOverlap { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct AxeOrient
    {
        public TitleOrientEnum? Enum;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator AxeOrient(TitleOrientEnum Enum) => new AxeOrient { Enum = Enum };
        public static implicit operator AxeOrient(FormatTypeSignalRef FormatTypeSignalRef) => new AxeOrient { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct TickBand
    {
        public TickBandEnum? Enum;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator TickBand(TickBandEnum Enum) => new TickBand { Enum = Enum };
        public static implicit operator TickBand(FormatTypeSignalRef FormatTypeSignalRef) => new TickBand { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct Interval
    {
        public TickCountEnum? Enum;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator Interval(TickCountEnum Enum) => new Interval { Enum = Enum };
        public static implicit operator Interval(FormatTypeSignalRef FormatTypeSignalRef) => new Interval { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct TickCount
    {
        public double? Double;
        public TickCountEnum? Enum;
        public TickCountSignalRef TickCountSignalRef;

        public static implicit operator TickCount(double Double) => new TickCount { Double = Double };
        public static implicit operator TickCount(TickCountEnum Enum) => new TickCount { Enum = Enum };
        public static implicit operator TickCount(TickCountSignalRef TickCountSignalRef) => new TickCount { TickCountSignalRef = TickCountSignalRef };
    }

    public partial struct TickExtraUnion
    {
        public bool? Bool;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator TickExtraUnion(bool Bool) => new TickExtraUnion { Bool = Bool };
        public static implicit operator TickExtraUnion(FormatTypeSignalRef FormatTypeSignalRef) => new TickExtraUnion { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct TickRoundUnion
    {
        public bool? Bool;
        public TickRoundClass TickRoundClass;
        public TickRoundElement[] TickRoundElementArray;

        public static implicit operator TickRoundUnion(bool Bool) => new TickRoundUnion { Bool = Bool };
        public static implicit operator TickRoundUnion(TickRoundClass TickRoundClass) => new TickRoundUnion { TickRoundClass = TickRoundClass };
        public static implicit operator TickRoundUnion(TickRoundElement[] TickRoundElementArray) => new TickRoundUnion { TickRoundElementArray = TickRoundElementArray };
    }

    public partial struct TextOrSignal
    {
        public FormatTypeSignalRef FormatTypeSignalRef;
        public string String;
        public string[] StringArray;

        public static implicit operator TextOrSignal(FormatTypeSignalRef FormatTypeSignalRef) => new TextOrSignal { FormatTypeSignalRef = FormatTypeSignalRef };
        public static implicit operator TextOrSignal(string String) => new TextOrSignal { String = String };
        public static implicit operator TextOrSignal(string[] StringArray) => new TextOrSignal { StringArray = StringArray };
    }

    public partial struct TitleAnchorUnion
    {
        public AnchorValue AnchorValue;
        public Anchor? Enum;
        public TitleAnchorElement[] TitleAnchorElementArray;

        public static implicit operator TitleAnchorUnion(AnchorValue AnchorValue) => new TitleAnchorUnion { AnchorValue = AnchorValue };
        public static implicit operator TitleAnchorUnion(Anchor Enum) => new TitleAnchorUnion { Enum = Enum };
        public static implicit operator TitleAnchorUnion(TitleAnchorElement[] TitleAnchorElementArray) => new TitleAnchorUnion { TitleAnchorElementArray = TitleAnchorElementArray };
        public bool IsNull => TitleAnchorElementArray == null && AnchorValue == null && Enum == null;
    }

    public partial struct ArrayOrSignal
    {
        public object[] AnythingArray;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator ArrayOrSignal(object[] AnythingArray) => new ArrayOrSignal { AnythingArray = AnythingArray };
        public static implicit operator ArrayOrSignal(FormatTypeSignalRef FormatTypeSignalRef) => new ArrayOrSignal { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct BackgroundElement
    {
        public FormatTypeSignalRef FormatTypeSignalRef;
        public string String;

        public static implicit operator BackgroundElement(FormatTypeSignalRef FormatTypeSignalRef) => new BackgroundElement { FormatTypeSignalRef = FormatTypeSignalRef };
        public static implicit operator BackgroundElement(string String) => new BackgroundElement { String = String };
    }

    public partial struct ParseUnion
    {
        public ParseEnum? Enum;
        public ParseSignalRef ParseSignalRef;

        public static implicit operator ParseUnion(ParseEnum Enum) => new ParseUnion { Enum = Enum };
        public static implicit operator ParseUnion(ParseSignalRef ParseSignalRef) => new ParseUnion { ParseSignalRef = ParseSignalRef };
    }

    public partial struct Remove
    {
        public bool? Bool;
        public string String;

        public static implicit operator Remove(bool Bool) => new Remove { Bool = Bool };
        public static implicit operator Remove(string String) => new Remove { String = String };
    }

    public partial struct AggregateParamElement
    {
        public double? Double;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator AggregateParamElement(double Double) => new AggregateParamElement { Double = Double };
        public static implicit operator AggregateParamElement(FormatTypeSignalRef FormatTypeSignalRef) => new AggregateParamElement { FormatTypeSignalRef = FormatTypeSignalRef };
        public bool IsNull => FormatTypeSignalRef == null && Double == null;
    }

    public partial struct Params
    {
        public AggregateParamElement[] AnythingArray;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator Params(AggregateParamElement[] AnythingArray) => new Params { AnythingArray = AnythingArray };
        public static implicit operator Params(FormatTypeSignalRef FormatTypeSignalRef) => new Params { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct AnchorUnion
    {
        public BackgroundElement[] AnythingArray;
        public double? Double;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator AnchorUnion(BackgroundElement[] AnythingArray) => new AnchorUnion { AnythingArray = AnythingArray };
        public static implicit operator AnchorUnion(double Double) => new AnchorUnion { Double = Double };
        public static implicit operator AnchorUnion(FormatTypeSignalRef FormatTypeSignalRef) => new AnchorUnion { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct AElement
    {
        public FormatTypeSignalRef FormatTypeSignalRef;
        public string String;

        public static implicit operator AElement(FormatTypeSignalRef FormatTypeSignalRef) => new AElement { FormatTypeSignalRef = FormatTypeSignalRef };
        public static implicit operator AElement(string String) => new AElement { String = String };
        public bool IsNull => FormatTypeSignalRef == null && String == null;
    }

    public partial struct TransformAs
    {
        public AElement[] AnythingArray;
        public FormatTypeSignalRef FormatTypeSignalRef;
        public string String;

        public static implicit operator TransformAs(AElement[] AnythingArray) => new TransformAs { AnythingArray = AnythingArray };
        public static implicit operator TransformAs(FormatTypeSignalRef FormatTypeSignalRef) => new TransformAs { FormatTypeSignalRef = FormatTypeSignalRef };
        public static implicit operator TransformAs(string String) => new TransformAs { String = String };
        public bool IsNull => AnythingArray == null && FormatTypeSignalRef == null && String == null;
    }

    public partial struct AvoidMarks
    {
        public FormatTypeSignalRef FormatTypeSignalRef;
        public string[] StringArray;

        public static implicit operator AvoidMarks(FormatTypeSignalRef FormatTypeSignalRef) => new AvoidMarks { FormatTypeSignalRef = FormatTypeSignalRef };
        public static implicit operator AvoidMarks(string[] StringArray) => new AvoidMarks { StringArray = StringArray };
    }

    public partial struct StepsUnion
    {
        public HeightElement[] AnythingArray;
        public double? Double;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator StepsUnion(HeightElement[] AnythingArray) => new StepsUnion { AnythingArray = AnythingArray };
        public static implicit operator StepsUnion(double Double) => new StepsUnion { Double = Double };
        public static implicit operator StepsUnion(FormatTypeSignalRef FormatTypeSignalRef) => new StepsUnion { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct CaseUnion
    {
        public CaseEnum? Enum;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator CaseUnion(CaseEnum Enum) => new CaseUnion { Enum = Enum };
        public static implicit operator CaseUnion(FormatTypeSignalRef FormatTypeSignalRef) => new CaseUnion { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct ColorElement
    {
        public ColorSignalRef ColorSignalRef;
        public string String;

        public static implicit operator ColorElement(ColorSignalRef ColorSignalRef) => new ColorElement { ColorSignalRef = ColorSignalRef };
        public static implicit operator ColorElement(string String) => new ColorElement { String = String };
    }

    public partial struct CenterElement
    {
        public HeightElement[] AnythingArray;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator CenterElement(HeightElement[] AnythingArray) => new CenterElement { AnythingArray = AnythingArray };
        public static implicit operator CenterElement(FormatTypeSignalRef FormatTypeSignalRef) => new CenterElement { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct FieldsField
    {
        public string String;
        public TentacledSignalRef TentacledSignalRef;

        public static implicit operator FieldsField(string String) => new FieldsField { String = String };
        public static implicit operator FieldsField(TentacledSignalRef TentacledSignalRef) => new FieldsField { TentacledSignalRef = TentacledSignalRef };
        public bool IsNull => TentacledSignalRef == null && String == null;
    }

    public partial struct FieldsUnion
    {
        public FieldsField[] AnythingArray;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator FieldsUnion(FieldsField[] AnythingArray) => new FieldsUnion { AnythingArray = AnythingArray };
        public static implicit operator FieldsUnion(FormatTypeSignalRef FormatTypeSignalRef) => new FieldsUnion { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct Radius
    {
        public double? Double;
        public FontSizeSignalRef FontSizeSignalRef;

        public static implicit operator Radius(double Double) => new Radius { Double = Double };
        public static implicit operator Radius(FontSizeSignalRef FontSizeSignalRef) => new Radius { FontSizeSignalRef = FontSizeSignalRef };
    }

    public partial struct FontSizeRange
    {
        public HeightElement[] AnythingArray;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator FontSizeRange(HeightElement[] AnythingArray) => new FontSizeRange { AnythingArray = AnythingArray };
        public static implicit operator FontSizeRange(FormatTypeSignalRef FormatTypeSignalRef) => new FontSizeRange { FormatTypeSignalRef = FormatTypeSignalRef };
        public bool IsNull => AnythingArray == null && FormatTypeSignalRef == null;
    }

    public partial struct StrengthUnion
    {
        public double? Double;
        public StrengthSignalRef StrengthSignalRef;

        public static implicit operator StrengthUnion(double Double) => new StrengthUnion { Double = Double };
        public static implicit operator StrengthUnion(StrengthSignalRef StrengthSignalRef) => new StrengthUnion { StrengthSignalRef = StrengthSignalRef };
    }

    public partial struct XUnion
    {
        public double? Double;
        public StickySignalRef StickySignalRef;
        public string String;

        public static implicit operator XUnion(double Double) => new XUnion { Double = Double };
        public static implicit operator XUnion(StickySignalRef StickySignalRef) => new XUnion { StickySignalRef = StickySignalRef };
        public static implicit operator XUnion(string String) => new XUnion { String = String };
    }

    public partial struct GroupbyUnion
    {
        public ColorElement[] AnythingArray;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator GroupbyUnion(ColorElement[] AnythingArray) => new GroupbyUnion { AnythingArray = AnythingArray };
        public static implicit operator GroupbyUnion(FormatTypeSignalRef FormatTypeSignalRef) => new GroupbyUnion { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct TransformOffset
    {
        public HeightElement[] AnythingArray;
        public OffsetEnum? Enum;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator TransformOffset(HeightElement[] AnythingArray) => new TransformOffset { AnythingArray = AnythingArray };
        public static implicit operator TransformOffset(OffsetEnum Enum) => new TransformOffset { Enum = Enum };
        public static implicit operator TransformOffset(FormatTypeSignalRef FormatTypeSignalRef) => new TransformOffset { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct TransformOp
    {
        public PurpleOp? Enum;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator TransformOp(PurpleOp Enum) => new TransformOp { Enum = Enum };
        public static implicit operator TransformOp(FormatTypeSignalRef FormatTypeSignalRef) => new TransformOp { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct OpElement
    {
        public FluffyOp? Enum;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator OpElement(FluffyOp Enum) => new OpElement { Enum = Enum };
        public static implicit operator OpElement(FormatTypeSignalRef FormatTypeSignalRef) => new OpElement { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct Ops
    {
        public OpElement[] AnythingArray;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator Ops(OpElement[] AnythingArray) => new Ops { AnythingArray = AnythingArray };
        public static implicit operator Ops(FormatTypeSignalRef FormatTypeSignalRef) => new Ops { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct TransformOrient
    {
        public PurpleOrient? Enum;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator TransformOrient(PurpleOrient Enum) => new TransformOrient { Enum = Enum };
        public static implicit operator TransformOrient(FormatTypeSignalRef FormatTypeSignalRef) => new TransformOrient { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct TransformPadding
    {
        public double? Double;
        public PaddingExpr PaddingExpr;

        public static implicit operator TransformPadding(double Double) => new TransformPadding { Double = Double };
        public static implicit operator TransformPadding(PaddingExpr PaddingExpr) => new TransformPadding { PaddingExpr = PaddingExpr };
        public bool IsNull => PaddingExpr == null && Double == null;
    }

    public partial struct ParamsUnion
    {
        public AggregateParamElement[] AnythingArray;
        public bool? Bool;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator ParamsUnion(AggregateParamElement[] AnythingArray) => new ParamsUnion { AnythingArray = AnythingArray };
        public static implicit operator ParamsUnion(bool Bool) => new ParamsUnion { Bool = Bool };
        public static implicit operator ParamsUnion(FormatTypeSignalRef FormatTypeSignalRef) => new ParamsUnion { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct ResolveUnion
    {
        public ResolveEnum? Enum;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator ResolveUnion(ResolveEnum Enum) => new ResolveUnion { Enum = Enum };
        public static implicit operator ResolveUnion(FormatTypeSignalRef FormatTypeSignalRef) => new ResolveUnion { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct ShapeUnion
    {
        public ShapeEnum? Enum;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator ShapeUnion(ShapeEnum Enum) => new ShapeUnion { Enum = Enum };
        public static implicit operator ShapeUnion(FormatTypeSignalRef FormatTypeSignalRef) => new ShapeUnion { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct FieldField
    {
        public IndigoSignalRef IndigoSignalRef;
        public string String;

        public static implicit operator FieldField(IndigoSignalRef IndigoSignalRef) => new FieldField { IndigoSignalRef = IndigoSignalRef };
        public static implicit operator FieldField(string String) => new FieldField { String = String };
    }

    public partial struct CompareField
    {
        public FieldField[] AnythingArray;
        public IndigoSignalRef IndigoSignalRef;
        public string String;

        public static implicit operator CompareField(FieldField[] AnythingArray) => new CompareField { AnythingArray = AnythingArray };
        public static implicit operator CompareField(IndigoSignalRef IndigoSignalRef) => new CompareField { IndigoSignalRef = IndigoSignalRef };
        public static implicit operator CompareField(string String) => new CompareField { String = String };
    }

    public partial struct SortOrder
    {
        public OrderEnum? Enum;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator SortOrder(OrderEnum Enum) => new SortOrder { Enum = Enum };
        public static implicit operator SortOrder(FormatTypeSignalRef FormatTypeSignalRef) => new SortOrder { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct OrderUnion
    {
        public SortOrder[] AnythingArray;
        public OrderEnum? Enum;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator OrderUnion(SortOrder[] AnythingArray) => new OrderUnion { AnythingArray = AnythingArray };
        public static implicit operator OrderUnion(OrderEnum Enum) => new OrderUnion { Enum = Enum };
        public static implicit operator OrderUnion(FormatTypeSignalRef FormatTypeSignalRef) => new OrderUnion { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct SortUnion
    {
        public bool? Bool;
        public CompareClass CompareClass;

        public static implicit operator SortUnion(bool Bool) => new SortUnion { Bool = Bool };
        public static implicit operator SortUnion(CompareClass CompareClass) => new SortUnion { CompareClass = CompareClass };
    }

    public partial struct TimezoneUnion
    {
        public TimezoneEnum? Enum;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator TimezoneUnion(TimezoneEnum Enum) => new TimezoneUnion { Enum = Enum };
        public static implicit operator TimezoneUnion(FormatTypeSignalRef FormatTypeSignalRef) => new TimezoneUnion { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct Translate
    {
        public Radius[] AnythingArray;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator Translate(Radius[] AnythingArray) => new Translate { AnythingArray = AnythingArray };
        public static implicit operator Translate(FormatTypeSignalRef FormatTypeSignalRef) => new Translate { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct UnitElement
    {
        public UnitEnum? Enum;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator UnitElement(UnitEnum Enum) => new UnitElement { Enum = Enum };
        public static implicit operator UnitElement(FormatTypeSignalRef FormatTypeSignalRef) => new UnitElement { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct Units
    {
        public UnitElement[] AnythingArray;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator Units(UnitElement[] AnythingArray) => new Units { AnythingArray = AnythingArray };
        public static implicit operator Units(FormatTypeSignalRef FormatTypeSignalRef) => new Units { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct ValueElement
    {
        public double? Double;
        public IndecentSignalRef IndecentSignalRef;
        public string String;

        public static implicit operator ValueElement(double Double) => new ValueElement { Double = Double };
        public static implicit operator ValueElement(IndecentSignalRef IndecentSignalRef) => new ValueElement { IndecentSignalRef = IndecentSignalRef };
        public static implicit operator ValueElement(string String) => new ValueElement { String = String };
    }

    public partial struct ValuesUnion
    {
        public ValueElement[] AnythingArray;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator ValuesUnion(ValueElement[] AnythingArray) => new ValuesUnion { AnythingArray = AnythingArray };
        public static implicit operator ValuesUnion(FormatTypeSignalRef FormatTypeSignalRef) => new ValuesUnion { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct AlignValue
    {
        public LabelAlignClass LabelAlignClass;
        public LabelAlignElement[] LabelAlignElementArray;

        public static implicit operator AlignValue(LabelAlignClass LabelAlignClass) => new AlignValue { LabelAlignClass = LabelAlignClass };
        public static implicit operator AlignValue(LabelAlignElement[] LabelAlignElementArray) => new AlignValue { LabelAlignElementArray = LabelAlignElementArray };
    }

    public partial struct BooleanValue
    {
        public TickRoundClass TickRoundClass;
        public TickRoundElement[] TickRoundElementArray;

        public static implicit operator BooleanValue(TickRoundClass TickRoundClass) => new BooleanValue { TickRoundClass = TickRoundClass };
        public static implicit operator BooleanValue(TickRoundElement[] TickRoundElementArray) => new BooleanValue { TickRoundElementArray = TickRoundElementArray };
    }

    public partial struct StringValue
    {
        public DomainCapClass DomainCapClass;
        public DomainCapElement[] DomainCapElementArray;

        public static implicit operator StringValue(DomainCapClass DomainCapClass) => new StringValue { DomainCapClass = DomainCapClass };
        public static implicit operator StringValue(DomainCapElement[] DomainCapElementArray) => new StringValue { DomainCapElementArray = DomainCapElementArray };
    }

    public partial struct BaselineValue
    {
        public LabelBaselineClass LabelBaselineClass;
        public LabelBaselineElement[] LabelBaselineElementArray;

        public static implicit operator BaselineValue(LabelBaselineClass LabelBaselineClass) => new BaselineValue { LabelBaselineClass = LabelBaselineClass };
        public static implicit operator BaselineValue(LabelBaselineElement[] LabelBaselineElementArray) => new BaselineValue { LabelBaselineElementArray = LabelBaselineElementArray };
    }

    public partial struct BlendValue
    {
        public BlendValueClass BlendValueClass;
        public BlendValueElement[] BlendValueElementArray;

        public static implicit operator BlendValue(BlendValueClass BlendValueClass) => new BlendValue { BlendValueClass = BlendValueClass };
        public static implicit operator BlendValue(BlendValueElement[] BlendValueElementArray) => new BlendValue { BlendValueElementArray = BlendValueElementArray };
    }

    public partial struct ColorValue
    {
        public BaseColorValue[] BaseColorValueArray;
        public FluffyBaseColorValue FluffyBaseColorValue;

        public static implicit operator ColorValue(BaseColorValue[] BaseColorValueArray) => new ColorValue { BaseColorValueArray = BaseColorValueArray };
        public static implicit operator ColorValue(FluffyBaseColorValue FluffyBaseColorValue) => new ColorValue { FluffyBaseColorValue = FluffyBaseColorValue };
    }

    public partial struct FontWeightValue
    {
        public LabelFontWeightClass LabelFontWeightClass;
        public LabelFontWeightElement[] LabelFontWeightElementArray;

        public static implicit operator FontWeightValue(LabelFontWeightClass LabelFontWeightClass) => new FontWeightValue { LabelFontWeightClass = LabelFontWeightClass };
        public static implicit operator FontWeightValue(LabelFontWeightElement[] LabelFontWeightElementArray) => new FontWeightValue { LabelFontWeightElementArray = LabelFontWeightElementArray };
    }

    public partial struct DirectionValue
    {
        public DirectionValueClass DirectionValueClass;
        public DirectionValueElement[] DirectionValueElementArray;

        public static implicit operator DirectionValue(DirectionValueClass DirectionValueClass) => new DirectionValue { DirectionValueClass = DirectionValueClass };
        public static implicit operator DirectionValue(DirectionValueElement[] DirectionValueElementArray) => new DirectionValue { DirectionValueElementArray = DirectionValueElementArray };
    }

    public partial struct StrokeCapValue
    {
        public StrokeCapValueClass StrokeCapValueClass;
        public StrokeCapValueElement[] StrokeCapValueElementArray;

        public static implicit operator StrokeCapValue(StrokeCapValueClass StrokeCapValueClass) => new StrokeCapValue { StrokeCapValueClass = StrokeCapValueClass };
        public static implicit operator StrokeCapValue(StrokeCapValueElement[] StrokeCapValueElementArray) => new StrokeCapValue { StrokeCapValueElementArray = StrokeCapValueElementArray };
    }

    public partial struct ArrayValue
    {
        public ArrayValueElement[] ArrayValueElementArray;
        public DomainDashClass DomainDashClass;

        public static implicit operator ArrayValue(ArrayValueElement[] ArrayValueElementArray) => new ArrayValue { ArrayValueElementArray = ArrayValueElementArray };
        public static implicit operator ArrayValue(DomainDashClass DomainDashClass) => new ArrayValue { DomainDashClass = DomainDashClass };
    }

    public partial struct StrokeJoinValue
    {
        public StrokeJoinValueClass StrokeJoinValueClass;
        public StrokeJoinValueElement[] StrokeJoinValueElementArray;

        public static implicit operator StrokeJoinValue(StrokeJoinValueClass StrokeJoinValueClass) => new StrokeJoinValue { StrokeJoinValueClass = StrokeJoinValueClass };
        public static implicit operator StrokeJoinValue(StrokeJoinValueElement[] StrokeJoinValueElementArray) => new StrokeJoinValue { StrokeJoinValueElementArray = StrokeJoinValueElementArray };
    }

    public partial struct TextValue
    {
        public TextValueClass TextValueClass;
        public TextValueElement[] TextValueElementArray;

        public static implicit operator TextValue(TextValueClass TextValueClass) => new TextValue { TextValueClass = TextValueClass };
        public static implicit operator TextValue(TextValueElement[] TextValueElementArray) => new TextValue { TextValueElementArray = TextValueElementArray };
    }

    public partial struct AnyValue
    {
        public AnyValueClass AnyValueClass;
        public AnyValueElement[] AnyValueElementArray;

        public static implicit operator AnyValue(AnyValueClass AnyValueClass) => new AnyValue { AnyValueClass = AnyValueClass };
        public static implicit operator AnyValue(AnyValueElement[] AnyValueElementArray) => new AnyValue { AnyValueElementArray = AnyValueElementArray };
    }

    public partial struct GridAlignUnion
    {
        public AlignEnum? Enum;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator GridAlignUnion(AlignEnum Enum) => new GridAlignUnion { Enum = Enum };
        public static implicit operator GridAlignUnion(FormatTypeSignalRef FormatTypeSignalRef) => new GridAlignUnion { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct AlignUnion
    {
        public AlignEnum? Enum;
        public HilariousSignalRef HilariousSignalRef;

        public static implicit operator AlignUnion(AlignEnum Enum) => new AlignUnion { Enum = Enum };
        public static implicit operator AlignUnion(HilariousSignalRef HilariousSignalRef) => new AlignUnion { HilariousSignalRef = HilariousSignalRef };
    }

    public partial struct BoundsUnion
    {
        public BoundsEnum? Enum;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator BoundsUnion(BoundsEnum Enum) => new BoundsUnion { Enum = Enum };
        public static implicit operator BoundsUnion(FormatTypeSignalRef FormatTypeSignalRef) => new BoundsUnion { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct Center
    {
        public AmbitiousSignalRef AmbitiousSignalRef;
        public bool? Bool;

        public static implicit operator Center(AmbitiousSignalRef AmbitiousSignalRef) => new Center { AmbitiousSignalRef = AmbitiousSignalRef };
        public static implicit operator Center(bool Bool) => new Center { Bool = Bool };
    }

    public partial struct FooterBandUnion
    {
        public double? Double;
        public FooterBandSignalRef FooterBandSignalRef;

        public static implicit operator FooterBandUnion(double Double) => new FooterBandUnion { Double = Double };
        public static implicit operator FooterBandUnion(FooterBandSignalRef FooterBandSignalRef) => new FooterBandUnion { FooterBandSignalRef = FooterBandSignalRef };
        public bool IsNull => FooterBandSignalRef == null && Double == null;
    }

    public partial struct HeaderBandUnion
    {
        public double? Double;
        public HeaderBandSignalRef HeaderBandSignalRef;

        public static implicit operator HeaderBandUnion(double Double) => new HeaderBandUnion { Double = Double };
        public static implicit operator HeaderBandUnion(HeaderBandSignalRef HeaderBandSignalRef) => new HeaderBandUnion { HeaderBandSignalRef = HeaderBandSignalRef };
        public bool IsNull => HeaderBandSignalRef == null && Double == null;
    }

    public partial struct LayoutOffset
    {
        public CunningSignalRef CunningSignalRef;
        public double? Double;

        public static implicit operator LayoutOffset(CunningSignalRef CunningSignalRef) => new LayoutOffset { CunningSignalRef = CunningSignalRef };
        public static implicit operator LayoutOffset(double Double) => new LayoutOffset { Double = Double };
    }

    public partial struct PaddingUnion
    {
        public double? Double;
        public MagentaSignalRef MagentaSignalRef;

        public static implicit operator PaddingUnion(double Double) => new PaddingUnion { Double = Double };
        public static implicit operator PaddingUnion(MagentaSignalRef MagentaSignalRef) => new PaddingUnion { MagentaSignalRef = MagentaSignalRef };
    }

    public partial struct PurpleColumn
    {
        public TitleAnchorEnum? Enum;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator PurpleColumn(TitleAnchorEnum Enum) => new PurpleColumn { Enum = Enum };
        public static implicit operator PurpleColumn(FormatTypeSignalRef FormatTypeSignalRef) => new PurpleColumn { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct TitleAnchor
    {
        public TitleAnchorEnum? Enum;
        public TitleAnchorSignalRef TitleAnchorSignalRef;

        public static implicit operator TitleAnchor(TitleAnchorEnum Enum) => new TitleAnchor { Enum = Enum };
        public static implicit operator TitleAnchor(TitleAnchorSignalRef TitleAnchorSignalRef) => new TitleAnchor { TitleAnchorSignalRef = TitleAnchorSignalRef };
    }

    public partial struct TitleBandUnion
    {
        public double? Double;
        public TitleBandSignalRef TitleBandSignalRef;

        public static implicit operator TitleBandUnion(double Double) => new TitleBandUnion { Double = Double };
        public static implicit operator TitleBandUnion(TitleBandSignalRef TitleBandSignalRef) => new TitleBandUnion { TitleBandSignalRef = TitleBandSignalRef };
        public bool IsNull => TitleBandSignalRef == null && Double == null;
    }

    public partial struct LegendFormat
    {
        public FriskySignalRef FriskySignalRef;
        public string String;

        public static implicit operator LegendFormat(FriskySignalRef FriskySignalRef) => new LegendFormat { FriskySignalRef = FriskySignalRef };
        public static implicit operator LegendFormat(string String) => new LegendFormat { String = String };
    }

    public partial struct LegendOrient
    {
        public FluffyOrient? Enum;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator LegendOrient(FluffyOrient Enum) => new LegendOrient { Enum = Enum };
        public static implicit operator LegendOrient(FormatTypeSignalRef FormatTypeSignalRef) => new LegendOrient { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct TitleOrientUnion
    {
        public TitleOrientEnum? Enum;
        public OrientValue OrientValue;
        public TitleOrientElement[] TitleOrientElementArray;

        public static implicit operator TitleOrientUnion(TitleOrientEnum Enum) => new TitleOrientUnion { Enum = Enum };
        public static implicit operator TitleOrientUnion(OrientValue OrientValue) => new TitleOrientUnion { OrientValue = OrientValue };
        public static implicit operator TitleOrientUnion(TitleOrientElement[] TitleOrientElementArray) => new TitleOrientUnion { TitleOrientElementArray = TitleOrientElementArray };
    }

    public partial struct Markclip
    {
        public bool? Bool;
        public MarkclipSignalRef MarkclipSignalRef;

        public static implicit operator Markclip(bool Bool) => new Markclip { Bool = Bool };
        public static implicit operator Markclip(MarkclipSignalRef MarkclipSignalRef) => new Markclip { MarkclipSignalRef = MarkclipSignalRef };
    }

    public partial struct Extent
    {
        public CenterElement[] AnythingArray;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator Extent(CenterElement[] AnythingArray) => new Extent { AnythingArray = AnythingArray };
        public static implicit operator Extent(FormatTypeSignalRef FormatTypeSignalRef) => new Extent { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct Fit
    {
        public object[] AnythingArray;
        public Dictionary<string, object> AnythingMap;

        public static implicit operator Fit(object[] AnythingArray) => new Fit { AnythingArray = AnythingArray };
        public static implicit operator Fit(Dictionary<string, object> AnythingMap) => new Fit { AnythingMap = AnythingMap };
    }

    public partial struct ScaleBins
    {
        public HeightElement[] AnythingArray;
        public ScaleBinsSignalRef ScaleBinsSignalRef;

        public static implicit operator ScaleBins(HeightElement[] AnythingArray) => new ScaleBins { AnythingArray = AnythingArray };
        public static implicit operator ScaleBins(ScaleBinsSignalRef ScaleBinsSignalRef) => new ScaleBins { ScaleBinsSignalRef = ScaleBinsSignalRef };
    }

    public partial struct Domain
    {
        public HeightElement[] AnythingArray;
        public bool? Bool;
        public double? Double;
        public FormatTypeSignalRef FormatTypeSignalRef;
        public string String;

        public static implicit operator Domain(HeightElement[] AnythingArray) => new Domain { AnythingArray = AnythingArray };
        public static implicit operator Domain(bool Bool) => new Domain { Bool = Bool };
        public static implicit operator Domain(double Double) => new Domain { Double = Double };
        public static implicit operator Domain(FormatTypeSignalRef FormatTypeSignalRef) => new Domain { FormatTypeSignalRef = FormatTypeSignalRef };
        public static implicit operator Domain(string String) => new Domain { String = String };
        public bool IsNull => AnythingArray == null && Bool == null && FormatTypeSignalRef == null && Double == null && String == null;
    }

    public partial struct FieldElement
    {
        public bool? Bool;
        public double? Double;
        public string String;

        public static implicit operator FieldElement(bool Bool) => new FieldElement { Bool = Bool };
        public static implicit operator FieldElement(double Double) => new FieldElement { Double = Double };
        public static implicit operator FieldElement(string String) => new FieldElement { String = String };
    }

    public partial struct PurpleStringOrSignal
    {
        public FieldElement[] AnythingArray;
        public BraggadociousSignalRef BraggadociousSignalRef;
        public string String;

        public static implicit operator PurpleStringOrSignal(FieldElement[] AnythingArray) => new PurpleStringOrSignal { AnythingArray = AnythingArray };
        public static implicit operator PurpleStringOrSignal(BraggadociousSignalRef BraggadociousSignalRef) => new PurpleStringOrSignal { BraggadociousSignalRef = BraggadociousSignalRef };
        public static implicit operator PurpleStringOrSignal(string String) => new PurpleStringOrSignal { String = String };
    }

    public partial struct TentacledSort
    {
        public bool? Bool;
        public PurpleSort PurpleSort;

        public static implicit operator TentacledSort(bool Bool) => new TentacledSort { Bool = Bool };
        public static implicit operator TentacledSort(PurpleSort PurpleSort) => new TentacledSort { PurpleSort = PurpleSort };
    }

    public partial struct ScaleData
    {
        public Domain[] AnythingArray;
        public MischievousSignalRef MischievousSignalRef;

        public static implicit operator ScaleData(Domain[] AnythingArray) => new ScaleData { AnythingArray = AnythingArray };
        public static implicit operator ScaleData(MischievousSignalRef MischievousSignalRef) => new ScaleData { MischievousSignalRef = MischievousSignalRef };
    }

    public partial struct DomainRaw
    {
        public object[] AnythingArray;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator DomainRaw(object[] AnythingArray) => new DomainRaw { AnythingArray = AnythingArray };
        public static implicit operator DomainRaw(FormatTypeSignalRef FormatTypeSignalRef) => new DomainRaw { FormatTypeSignalRef = FormatTypeSignalRef };
        public bool IsNull => AnythingArray == null && FormatTypeSignalRef == null;
    }

    public partial struct ScaleInterpolate
    {
        public ScaleInterpolateSignalRef ScaleInterpolateSignalRef;
        public string String;

        public static implicit operator ScaleInterpolate(ScaleInterpolateSignalRef ScaleInterpolateSignalRef) => new ScaleInterpolate { ScaleInterpolateSignalRef = ScaleInterpolateSignalRef };
        public static implicit operator ScaleInterpolate(string String) => new ScaleInterpolate { String = String };
    }

    public partial struct PurpleBooleanOrSignal
    {
        public bool? Bool;
        public double? Double;
        public TickCountEnum? Enum;
        public SignalRef1 SignalRef1;

        public static implicit operator PurpleBooleanOrSignal(bool Bool) => new PurpleBooleanOrSignal { Bool = Bool };
        public static implicit operator PurpleBooleanOrSignal(double Double) => new PurpleBooleanOrSignal { Double = Double };
        public static implicit operator PurpleBooleanOrSignal(TickCountEnum Enum) => new PurpleBooleanOrSignal { Enum = Enum };
        public static implicit operator PurpleBooleanOrSignal(SignalRef1 SignalRef1) => new PurpleBooleanOrSignal { SignalRef1 = SignalRef1 };
    }

    public partial struct FluffyStringOrSignal
    {
        public FieldElement[] AnythingArray;
        public SignalRef3 SignalRef3;
        public string String;

        public static implicit operator FluffyStringOrSignal(FieldElement[] AnythingArray) => new FluffyStringOrSignal { AnythingArray = AnythingArray };
        public static implicit operator FluffyStringOrSignal(SignalRef3 SignalRef3) => new FluffyStringOrSignal { SignalRef3 = SignalRef3 };
        public static implicit operator FluffyStringOrSignal(string String) => new FluffyStringOrSignal { String = String };
    }

    public partial struct Scheme
    {
        public BackgroundElement[] AnythingArray;
        public FormatTypeSignalRef FormatTypeSignalRef;
        public string String;

        public static implicit operator Scheme(BackgroundElement[] AnythingArray) => new Scheme { AnythingArray = AnythingArray };
        public static implicit operator Scheme(FormatTypeSignalRef FormatTypeSignalRef) => new Scheme { FormatTypeSignalRef = FormatTypeSignalRef };
        public static implicit operator Scheme(string String) => new Scheme { String = String };
    }

    public partial struct StickySort
    {
        public bool? Bool;
        public FluffySort FluffySort;

        public static implicit operator StickySort(bool Bool) => new StickySort { Bool = Bool };
        public static implicit operator StickySort(FluffySort FluffySort) => new StickySort { FluffySort = FluffySort };
    }

    public partial struct RangeUnion
    {
        public Domain[] AnythingArray;
        public RangeEnum? Enum;
        public SignalRef2 SignalRef2;

        public static implicit operator RangeUnion(Domain[] AnythingArray) => new RangeUnion { AnythingArray = AnythingArray };
        public static implicit operator RangeUnion(RangeEnum Enum) => new RangeUnion { Enum = Enum };
        public static implicit operator RangeUnion(SignalRef2 SignalRef2) => new RangeUnion { SignalRef2 = SignalRef2 };
    }

    public partial struct EventsUnion
    {
        public Listener[] ListenerArray;
        public StreamClass StreamClass;
        public string String;

        public static implicit operator EventsUnion(Listener[] ListenerArray) => new EventsUnion { ListenerArray = ListenerArray };
        public static implicit operator EventsUnion(StreamClass StreamClass) => new EventsUnion { StreamClass = StreamClass };
        public static implicit operator EventsUnion(string String) => new EventsUnion { String = String };
    }

    public partial struct Update
    {
        public Expr Expr;
        public string String;

        public static implicit operator Update(Expr Expr) => new Update { Expr = Expr };
        public static implicit operator Update(string String) => new Update { String = String };
    }

    public partial struct FrameUnion
    {
        public DomainCapClass DomainCapClass;
        public DomainCapElement[] DomainCapElementArray;
        public Frame? Enum;

        public static implicit operator FrameUnion(DomainCapClass DomainCapClass) => new FrameUnion { DomainCapClass = DomainCapClass };
        public static implicit operator FrameUnion(DomainCapElement[] DomainCapElementArray) => new FrameUnion { DomainCapElementArray = DomainCapElementArray };
        public static implicit operator FrameUnion(Frame Enum) => new FrameUnion { Enum = Enum };
    }

    public partial struct TitleOrient
    {
        public TentacledOrient? Enum;
        public FormatTypeSignalRef FormatTypeSignalRef;

        public static implicit operator TitleOrient(TentacledOrient Enum) => new TitleOrient { Enum = Enum };
        public static implicit operator TitleOrient(FormatTypeSignalRef FormatTypeSignalRef) => new TitleOrient { FormatTypeSignalRef = FormatTypeSignalRef };
    }

    public partial struct Title
    {
        public string String;
        public TitleClass TitleClass;

        public static implicit operator Title(string String) => new Title { String = String };
        public static implicit operator Title(TitleClass TitleClass) => new Title { TitleClass = TitleClass };
    }

    public partial struct TransformMarkAs
    {
        public AElement[] AnythingArray;
        public FormatTypeSignalRef FormatTypeSignalRef;
        public string String;

        public static implicit operator TransformMarkAs(AElement[] AnythingArray) => new TransformMarkAs { AnythingArray = AnythingArray };
        public static implicit operator TransformMarkAs(FormatTypeSignalRef FormatTypeSignalRef) => new TransformMarkAs { FormatTypeSignalRef = FormatTypeSignalRef };
        public static implicit operator TransformMarkAs(string String) => new TransformMarkAs { String = String };
    }

    public partial struct Padding
    {
        public double? Double;
        public SignalRef4 SignalRef4;

        public static implicit operator Padding(double Double) => new Padding { Double = Double };
        public static implicit operator Padding(SignalRef4 SignalRef4) => new Padding { SignalRef4 = SignalRef4 };
    }

    public partial class Vega
    {
        public static Vega FromJson(string json) => JsonConvert.DeserializeObject<Vega>(json, PSGraph.Vega.Spec.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Vega self) => JsonConvert.SerializeObject(self, PSGraph.Vega.Spec.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            NullValueHandling = NullValueHandling.Ignore,
            Converters =
            {
                AutosizeConverter.Singleton,
                ContainsConverter.Singleton,
                AutosizeEnumConverter.Singleton,
                BandPositionUnionConverter.Singleton,
                BandConverter.Singleton,
                FieldConverter.Singleton,
                DomainCapUnionConverter.Singleton,
                DomainColorUnionConverter.Singleton,
                NumberValueConverter.Singleton,
                DomainDashUnionConverter.Singleton,
                DashConverter.Singleton,
                StyleConverter.Singleton,
                AxeFormatConverter.Singleton,
                FormatTypeUnionConverter.Singleton,
                FormatTypeEnumConverter.Singleton,
                LabelAlignUnionConverter.Singleton,
                LabelAlignEnumConverter.Singleton,
                LabelBaselineUnionConverter.Singleton,
                BaselineConverter.Singleton,
                LabelBoundConverter.Singleton,
                HeightElementConverter.Singleton,
                LabelFontWeightUnionConverter.Singleton,
                FontWeightConverter.Singleton,
                LabelOverlapConverter.Singleton,
                LabelOverlapEnumConverter.Singleton,
                AxeOrientConverter.Singleton,
                TitleOrientEnumConverter.Singleton,
                TickBandConverter.Singleton,
                TickBandEnumConverter.Singleton,
                TickCountConverter.Singleton,
                IntervalConverter.Singleton,
                TickCountEnumConverter.Singleton,
                TickExtraUnionConverter.Singleton,
                TickRoundUnionConverter.Singleton,
                TextOrSignalConverter.Singleton,
                TitleAnchorUnionConverter.Singleton,
                AnchorConverter.Singleton,
                ArrayOrSignalConverter.Singleton,
                BackgroundElementConverter.Singleton,
                FilterConverter.Singleton,
                ParseUnionConverter.Singleton,
                ParseEnumConverter.Singleton,
                RemoveConverter.Singleton,
                ParamsConverter.Singleton,
                AggregateParamElementConverter.Singleton,
                AnchorUnionConverter.Singleton,
                TransformAsConverter.Singleton,
                AElementConverter.Singleton,
                AvoidMarksConverter.Singleton,
                StepsUnionConverter.Singleton,
                CaseUnionConverter.Singleton,
                CaseEnumConverter.Singleton,
                ColorElementConverter.Singleton,
                FunctionConverter.Singleton,
                CenterElementConverter.Singleton,
                FieldsUnionConverter.Singleton,
                FieldsFieldConverter.Singleton,
                RadiusConverter.Singleton,
                FontSizeRangeConverter.Singleton,
                ForceEnumConverter.Singleton,
                StrengthUnionConverter.Singleton,
                XUnionConverter.Singleton,
                GroupbyUnionConverter.Singleton,
                TransformOffsetConverter.Singleton,
                OffsetEnumConverter.Singleton,
                TransformOpConverter.Singleton,
                PurpleOpConverter.Singleton,
                OpsConverter.Singleton,
                OpElementConverter.Singleton,
                FluffyOpConverter.Singleton,
                TransformOrientConverter.Singleton,
                PurpleOrientConverter.Singleton,
                TransformPaddingConverter.Singleton,
                ParamsUnionConverter.Singleton,
                ResolveUnionConverter.Singleton,
                ResolveEnumConverter.Singleton,
                ShapeUnionConverter.Singleton,
                ShapeEnumConverter.Singleton,
                SortUnionConverter.Singleton,
                CompareFieldConverter.Singleton,
                FieldFieldConverter.Singleton,
                OrderUnionConverter.Singleton,
                SortOrderConverter.Singleton,
                OrderEnumConverter.Singleton,
                TimezoneUnionConverter.Singleton,
                TimezoneEnumConverter.Singleton,
                TranslateConverter.Singleton,
                TransformTypeConverter.Singleton,
                UnitsConverter.Singleton,
                UnitElementConverter.Singleton,
                UnitEnumConverter.Singleton,
                ValuesUnionConverter.Singleton,
                ValueElementConverter.Singleton,
                AlignValueConverter.Singleton,
                BooleanValueConverter.Singleton,
                StringValueConverter.Singleton,
                BaselineValueConverter.Singleton,
                BlendValueConverter.Singleton,
                ColorValueConverter.Singleton,
                FontWeightValueConverter.Singleton,
                DirectionValueConverter.Singleton,
                StrokeCapValueConverter.Singleton,
                ArrayValueConverter.Singleton,
                StrokeJoinValueConverter.Singleton,
                TextValueConverter.Singleton,
                AnyValueConverter.Singleton,
                AlignUnionConverter.Singleton,
                GridAlignUnionConverter.Singleton,
                AlignEnumConverter.Singleton,
                BoundsUnionConverter.Singleton,
                BoundsEnumConverter.Singleton,
                CenterConverter.Singleton,
                FooterBandUnionConverter.Singleton,
                HeaderBandUnionConverter.Singleton,
                LayoutOffsetConverter.Singleton,
                PaddingUnionConverter.Singleton,
                TitleAnchorConverter.Singleton,
                PurpleColumnConverter.Singleton,
                TitleAnchorEnumConverter.Singleton,
                TitleBandUnionConverter.Singleton,
                DirectionConverter.Singleton,
                LegendFormatConverter.Singleton,
                LegendOrientConverter.Singleton,
                FluffyOrientConverter.Singleton,
                TitleOrientUnionConverter.Singleton,
                LegendTypeConverter.Singleton,
                MarkclipConverter.Singleton,
                ExtentConverter.Singleton,
                FitConverter.Singleton,
                ScaleBinsConverter.Singleton,
                ScaleDataConverter.Singleton,
                DomainConverter.Singleton,
                PurpleStringOrSignalConverter.Singleton,
                FieldElementConverter.Singleton,
                TentacledSortConverter.Singleton,
                DomainRawConverter.Singleton,
                ScaleInterpolateConverter.Singleton,
                PurpleBooleanOrSignalConverter.Singleton,
                RangeUnionConverter.Singleton,
                FluffyStringOrSignalConverter.Singleton,
                SchemeConverter.Singleton,
                StickySortConverter.Singleton,
                RangeEnumConverter.Singleton,
                ScaleTypeConverter.Singleton,
                EventsUnionConverter.Singleton,
                UpdateConverter.Singleton,
                PushConverter.Singleton,
                TitleConverter.Singleton,
                FrameUnionConverter.Singleton,
                FrameConverter.Singleton,
                TitleOrientConverter.Singleton,
                TentacledOrientConverter.Singleton,
                TransformMarkAsConverter.Singleton,
                TransformMarkTypeConverter.Singleton,
                PaddingConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class AutosizeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Autosize) || t == typeof(Autosize?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "fit":
                            return new Autosize { Enum = AutosizeEnum.Fit };
                        case "fit-x":
                            return new Autosize { Enum = AutosizeEnum.FitX };
                        case "fit-y":
                            return new Autosize { Enum = AutosizeEnum.FitY };
                        case "none":
                            return new Autosize { Enum = AutosizeEnum.None };
                        case "pad":
                            return new Autosize { Enum = AutosizeEnum.Pad };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<AutosizeSignalRef>(reader);
                    return new Autosize { AutosizeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type Autosize");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Autosize)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case AutosizeEnum.Fit:
                        serializer.Serialize(writer, "fit");
                        return;
                    case AutosizeEnum.FitX:
                        serializer.Serialize(writer, "fit-x");
                        return;
                    case AutosizeEnum.FitY:
                        serializer.Serialize(writer, "fit-y");
                        return;
                    case AutosizeEnum.None:
                        serializer.Serialize(writer, "none");
                        return;
                    case AutosizeEnum.Pad:
                        serializer.Serialize(writer, "pad");
                        return;
                }
            }
            if (value.AutosizeSignalRef != null)
            {
                serializer.Serialize(writer, value.AutosizeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type Autosize");
        }

        public static readonly AutosizeConverter Singleton = new AutosizeConverter();
    }

    internal class ContainsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Contains) || t == typeof(Contains?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "content":
                    return Contains.Content;
                case "padding":
                    return Contains.Padding;
            }
            throw new Exception("Cannot unmarshal type Contains");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Contains)untypedValue;
            switch (value)
            {
                case Contains.Content:
                    serializer.Serialize(writer, "content");
                    return;
                case Contains.Padding:
                    serializer.Serialize(writer, "padding");
                    return;
            }
            throw new Exception("Cannot marshal type Contains");
        }

        public static readonly ContainsConverter Singleton = new ContainsConverter();
    }

    internal class AutosizeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AutosizeEnum) || t == typeof(AutosizeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "fit":
                    return AutosizeEnum.Fit;
                case "fit-x":
                    return AutosizeEnum.FitX;
                case "fit-y":
                    return AutosizeEnum.FitY;
                case "none":
                    return AutosizeEnum.None;
                case "pad":
                    return AutosizeEnum.Pad;
            }
            throw new Exception("Cannot unmarshal type AutosizeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AutosizeEnum)untypedValue;
            switch (value)
            {
                case AutosizeEnum.Fit:
                    serializer.Serialize(writer, "fit");
                    return;
                case AutosizeEnum.FitX:
                    serializer.Serialize(writer, "fit-x");
                    return;
                case AutosizeEnum.FitY:
                    serializer.Serialize(writer, "fit-y");
                    return;
                case AutosizeEnum.None:
                    serializer.Serialize(writer, "none");
                    return;
                case AutosizeEnum.Pad:
                    serializer.Serialize(writer, "pad");
                    return;
            }
            throw new Exception("Cannot marshal type AutosizeEnum");
        }

        public static readonly AutosizeEnumConverter Singleton = new AutosizeEnumConverter();
    }

    internal class BandPositionUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BandPositionUnion) || t == typeof(BandPositionUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new BandPositionUnion { Double = doubleValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<BandPositionClass>(reader);
                    return new BandPositionUnion { BandPositionClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<BandPositionElement[]>(reader);
                    return new BandPositionUnion { BandPositionElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type BandPositionUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (BandPositionUnion)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.BandPositionElementArray != null)
            {
                serializer.Serialize(writer, value.BandPositionElementArray);
                return;
            }
            if (value.BandPositionClass != null)
            {
                serializer.Serialize(writer, value.BandPositionClass);
                return;
            }
            throw new Exception("Cannot marshal type BandPositionUnion");
        }

        public static readonly BandPositionUnionConverter Singleton = new BandPositionUnionConverter();
    }

    internal class BandConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Band) || t == typeof(Band?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Band { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new Band { Bool = boolValue };
            }
            throw new Exception("Cannot unmarshal type Band");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Band)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            throw new Exception("Cannot marshal type Band");
        }

        public static readonly BandConverter Singleton = new BandConverter();
    }

    internal class FieldConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Field) || t == typeof(Field?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Field { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<PurpleSignalRef>(reader);
                    return new Field { PurpleSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type Field");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Field)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.PurpleSignalRef != null)
            {
                serializer.Serialize(writer, value.PurpleSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type Field");
        }

        public static readonly FieldConverter Singleton = new FieldConverter();
    }

    internal class DomainCapUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DomainCapUnion) || t == typeof(DomainCapUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new DomainCapUnion { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<DomainCapClass>(reader);
                    return new DomainCapUnion { DomainCapClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<DomainCapElement[]>(reader);
                    return new DomainCapUnion { DomainCapElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type DomainCapUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (DomainCapUnion)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.DomainCapElementArray != null)
            {
                serializer.Serialize(writer, value.DomainCapElementArray);
                return;
            }
            if (value.DomainCapClass != null)
            {
                serializer.Serialize(writer, value.DomainCapClass);
                return;
            }
            throw new Exception("Cannot marshal type DomainCapUnion");
        }

        public static readonly DomainCapUnionConverter Singleton = new DomainCapUnionConverter();
    }

    internal class DomainColorUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DomainColorUnion) || t == typeof(DomainColorUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new DomainColorUnion { };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new DomainColorUnion { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<PurpleBaseColorValue>(reader);
                    return new DomainColorUnion { PurpleBaseColorValue = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<BaseColorValue[]>(reader);
                    return new DomainColorUnion { BaseColorValueArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type DomainColorUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (DomainColorUnion)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.BaseColorValueArray != null)
            {
                serializer.Serialize(writer, value.BaseColorValueArray);
                return;
            }
            if (value.PurpleBaseColorValue != null)
            {
                serializer.Serialize(writer, value.PurpleBaseColorValue);
                return;
            }
            throw new Exception("Cannot marshal type DomainColorUnion");
        }

        public static readonly DomainColorUnionConverter Singleton = new DomainColorUnionConverter();
    }

    internal class NumberValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(NumberValue) || t == typeof(NumberValue?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<BandPositionClass>(reader);
                    return new NumberValue { BandPositionClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<BandPositionElement[]>(reader);
                    return new NumberValue { BandPositionElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type NumberValue");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (NumberValue)untypedValue;
            if (value.BandPositionElementArray != null)
            {
                serializer.Serialize(writer, value.BandPositionElementArray);
                return;
            }
            if (value.BandPositionClass != null)
            {
                serializer.Serialize(writer, value.BandPositionClass);
                return;
            }
            throw new Exception("Cannot marshal type NumberValue");
        }

        public static readonly NumberValueConverter Singleton = new NumberValueConverter();
    }

    internal class DomainDashUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DomainDashUnion) || t == typeof(DomainDashUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<DomainDashClass>(reader);
                    return new DomainDashUnion { DomainDashClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<Dash[]>(reader);
                    return new DomainDashUnion { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type DomainDashUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (DomainDashUnion)untypedValue;
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.DomainDashClass != null)
            {
                serializer.Serialize(writer, value.DomainDashClass);
                return;
            }
            throw new Exception("Cannot marshal type DomainDashUnion");
        }

        public static readonly DomainDashUnionConverter Singleton = new DomainDashUnionConverter();
    }

    internal class DashConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Dash) || t == typeof(Dash?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Dash { Double = doubleValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<ArrayValueElement>(reader);
                    return new Dash { ArrayValueElement = objectValue };
            }
            throw new Exception("Cannot unmarshal type Dash");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Dash)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.ArrayValueElement != null)
            {
                serializer.Serialize(writer, value.ArrayValueElement);
                return;
            }
            throw new Exception("Cannot marshal type Dash");
        }

        public static readonly DashConverter Singleton = new DashConverter();
    }

    internal class StyleConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Style) || t == typeof(Style?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Style { String = stringValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<string[]>(reader);
                    return new Style { StringArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Style");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Style)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.StringArray != null)
            {
                serializer.Serialize(writer, value.StringArray);
                return;
            }
            throw new Exception("Cannot marshal type Style");
        }

        public static readonly StyleConverter Singleton = new StyleConverter();
    }

    internal class AxeFormatConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AxeFormat) || t == typeof(AxeFormat?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new AxeFormat { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FluffySignalRef>(reader);
                    return new AxeFormat { FluffySignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type AxeFormat");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (AxeFormat)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.FluffySignalRef != null)
            {
                serializer.Serialize(writer, value.FluffySignalRef);
                return;
            }
            throw new Exception("Cannot marshal type AxeFormat");
        }

        public static readonly AxeFormatConverter Singleton = new AxeFormatConverter();
    }

    internal class FormatTypeUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FormatTypeUnion) || t == typeof(FormatTypeUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "number":
                            return new FormatTypeUnion { Enum = FormatTypeEnum.Number };
                        case "time":
                            return new FormatTypeUnion { Enum = FormatTypeEnum.Time };
                        case "utc":
                            return new FormatTypeUnion { Enum = FormatTypeEnum.Utc };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new FormatTypeUnion { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type FormatTypeUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (FormatTypeUnion)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case FormatTypeEnum.Number:
                        serializer.Serialize(writer, "number");
                        return;
                    case FormatTypeEnum.Time:
                        serializer.Serialize(writer, "time");
                        return;
                    case FormatTypeEnum.Utc:
                        serializer.Serialize(writer, "utc");
                        return;
                }
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type FormatTypeUnion");
        }

        public static readonly FormatTypeUnionConverter Singleton = new FormatTypeUnionConverter();
    }

    internal class FormatTypeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FormatTypeEnum) || t == typeof(FormatTypeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "number":
                    return FormatTypeEnum.Number;
                case "time":
                    return FormatTypeEnum.Time;
                case "utc":
                    return FormatTypeEnum.Utc;
            }
            throw new Exception("Cannot unmarshal type FormatTypeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FormatTypeEnum)untypedValue;
            switch (value)
            {
                case FormatTypeEnum.Number:
                    serializer.Serialize(writer, "number");
                    return;
                case FormatTypeEnum.Time:
                    serializer.Serialize(writer, "time");
                    return;
                case FormatTypeEnum.Utc:
                    serializer.Serialize(writer, "utc");
                    return;
            }
            throw new Exception("Cannot marshal type FormatTypeEnum");
        }

        public static readonly FormatTypeEnumConverter Singleton = new FormatTypeEnumConverter();
    }

    internal class LabelAlignUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LabelAlignUnion) || t == typeof(LabelAlignUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "center":
                            return new LabelAlignUnion { Enum = LabelAlignEnum.Center };
                        case "left":
                            return new LabelAlignUnion { Enum = LabelAlignEnum.Left };
                        case "right":
                            return new LabelAlignUnion { Enum = LabelAlignEnum.Right };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<LabelAlignClass>(reader);
                    return new LabelAlignUnion { LabelAlignClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<LabelAlignElement[]>(reader);
                    return new LabelAlignUnion { LabelAlignElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type LabelAlignUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (LabelAlignUnion)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case LabelAlignEnum.Center:
                        serializer.Serialize(writer, "center");
                        return;
                    case LabelAlignEnum.Left:
                        serializer.Serialize(writer, "left");
                        return;
                    case LabelAlignEnum.Right:
                        serializer.Serialize(writer, "right");
                        return;
                }
            }
            if (value.LabelAlignElementArray != null)
            {
                serializer.Serialize(writer, value.LabelAlignElementArray);
                return;
            }
            if (value.LabelAlignClass != null)
            {
                serializer.Serialize(writer, value.LabelAlignClass);
                return;
            }
            throw new Exception("Cannot marshal type LabelAlignUnion");
        }

        public static readonly LabelAlignUnionConverter Singleton = new LabelAlignUnionConverter();
    }

    internal class LabelAlignEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LabelAlignEnum) || t == typeof(LabelAlignEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "center":
                    return LabelAlignEnum.Center;
                case "left":
                    return LabelAlignEnum.Left;
                case "right":
                    return LabelAlignEnum.Right;
            }
            throw new Exception("Cannot unmarshal type LabelAlignEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (LabelAlignEnum)untypedValue;
            switch (value)
            {
                case LabelAlignEnum.Center:
                    serializer.Serialize(writer, "center");
                    return;
                case LabelAlignEnum.Left:
                    serializer.Serialize(writer, "left");
                    return;
                case LabelAlignEnum.Right:
                    serializer.Serialize(writer, "right");
                    return;
            }
            throw new Exception("Cannot marshal type LabelAlignEnum");
        }

        public static readonly LabelAlignEnumConverter Singleton = new LabelAlignEnumConverter();
    }

    internal class LabelBaselineUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LabelBaselineUnion) || t == typeof(LabelBaselineUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "alphabetic":
                            return new LabelBaselineUnion { Enum = Baseline.Alphabetic };
                        case "bottom":
                            return new LabelBaselineUnion { Enum = Baseline.Bottom };
                        case "line-bottom":
                            return new LabelBaselineUnion { Enum = Baseline.LineBottom };
                        case "line-top":
                            return new LabelBaselineUnion { Enum = Baseline.LineTop };
                        case "middle":
                            return new LabelBaselineUnion { Enum = Baseline.Middle };
                        case "top":
                            return new LabelBaselineUnion { Enum = Baseline.Top };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<LabelBaselineClass>(reader);
                    return new LabelBaselineUnion { LabelBaselineClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<LabelBaselineElement[]>(reader);
                    return new LabelBaselineUnion { LabelBaselineElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type LabelBaselineUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (LabelBaselineUnion)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case Baseline.Alphabetic:
                        serializer.Serialize(writer, "alphabetic");
                        return;
                    case Baseline.Bottom:
                        serializer.Serialize(writer, "bottom");
                        return;
                    case Baseline.LineBottom:
                        serializer.Serialize(writer, "line-bottom");
                        return;
                    case Baseline.LineTop:
                        serializer.Serialize(writer, "line-top");
                        return;
                    case Baseline.Middle:
                        serializer.Serialize(writer, "middle");
                        return;
                    case Baseline.Top:
                        serializer.Serialize(writer, "top");
                        return;
                }
            }
            if (value.LabelBaselineElementArray != null)
            {
                serializer.Serialize(writer, value.LabelBaselineElementArray);
                return;
            }
            if (value.LabelBaselineClass != null)
            {
                serializer.Serialize(writer, value.LabelBaselineClass);
                return;
            }
            throw new Exception("Cannot marshal type LabelBaselineUnion");
        }

        public static readonly LabelBaselineUnionConverter Singleton = new LabelBaselineUnionConverter();
    }

    internal class BaselineConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Baseline) || t == typeof(Baseline?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "alphabetic":
                    return Baseline.Alphabetic;
                case "bottom":
                    return Baseline.Bottom;
                case "line-bottom":
                    return Baseline.LineBottom;
                case "line-top":
                    return Baseline.LineTop;
                case "middle":
                    return Baseline.Middle;
                case "top":
                    return Baseline.Top;
            }
            throw new Exception("Cannot unmarshal type Baseline");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Baseline)untypedValue;
            switch (value)
            {
                case Baseline.Alphabetic:
                    serializer.Serialize(writer, "alphabetic");
                    return;
                case Baseline.Bottom:
                    serializer.Serialize(writer, "bottom");
                    return;
                case Baseline.LineBottom:
                    serializer.Serialize(writer, "line-bottom");
                    return;
                case Baseline.LineTop:
                    serializer.Serialize(writer, "line-top");
                    return;
                case Baseline.Middle:
                    serializer.Serialize(writer, "middle");
                    return;
                case Baseline.Top:
                    serializer.Serialize(writer, "top");
                    return;
            }
            throw new Exception("Cannot marshal type Baseline");
        }

        public static readonly BaselineConverter Singleton = new BaselineConverter();
    }

    internal class LabelBoundConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LabelBound) || t == typeof(LabelBound?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new LabelBound { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new LabelBound { Bool = boolValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new LabelBound { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type LabelBound");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (LabelBound)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type LabelBound");
        }

        public static readonly LabelBoundConverter Singleton = new LabelBoundConverter();
    }

    internal class HeightElementConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(HeightElement) || t == typeof(HeightElement?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new HeightElement { Double = doubleValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new HeightElement { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type HeightElement");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (HeightElement)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type HeightElement");
        }

        public static readonly HeightElementConverter Singleton = new HeightElementConverter();
    }

    internal class LabelFontWeightUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LabelFontWeightUnion) || t == typeof(LabelFontWeightUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new LabelFontWeightUnion { };
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new LabelFontWeightUnion { Integer = integerValue };
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new LabelFontWeightUnion { Double = doubleValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "100":
                            return new LabelFontWeightUnion { Enum = FontWeight.The100 };
                        case "200":
                            return new LabelFontWeightUnion { Enum = FontWeight.The200 };
                        case "300":
                            return new LabelFontWeightUnion { Enum = FontWeight.The300 };
                        case "400":
                            return new LabelFontWeightUnion { Enum = FontWeight.The400 };
                        case "500":
                            return new LabelFontWeightUnion { Enum = FontWeight.The500 };
                        case "600":
                            return new LabelFontWeightUnion { Enum = FontWeight.The600 };
                        case "700":
                            return new LabelFontWeightUnion { Enum = FontWeight.The700 };
                        case "800":
                            return new LabelFontWeightUnion { Enum = FontWeight.The800 };
                        case "900":
                            return new LabelFontWeightUnion { Enum = FontWeight.The900 };
                        case "bold":
                            return new LabelFontWeightUnion { Enum = FontWeight.Bold };
                        case "bolder":
                            return new LabelFontWeightUnion { Enum = FontWeight.Bolder };
                        case "lighter":
                            return new LabelFontWeightUnion { Enum = FontWeight.Lighter };
                        case "normal":
                            return new LabelFontWeightUnion { Enum = FontWeight.Normal };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<LabelFontWeightClass>(reader);
                    return new LabelFontWeightUnion { LabelFontWeightClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<LabelFontWeightElement[]>(reader);
                    return new LabelFontWeightUnion { LabelFontWeightElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type LabelFontWeightUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (LabelFontWeightUnion)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case FontWeight.The100:
                        serializer.Serialize(writer, "100");
                        return;
                    case FontWeight.The200:
                        serializer.Serialize(writer, "200");
                        return;
                    case FontWeight.The300:
                        serializer.Serialize(writer, "300");
                        return;
                    case FontWeight.The400:
                        serializer.Serialize(writer, "400");
                        return;
                    case FontWeight.The500:
                        serializer.Serialize(writer, "500");
                        return;
                    case FontWeight.The600:
                        serializer.Serialize(writer, "600");
                        return;
                    case FontWeight.The700:
                        serializer.Serialize(writer, "700");
                        return;
                    case FontWeight.The800:
                        serializer.Serialize(writer, "800");
                        return;
                    case FontWeight.The900:
                        serializer.Serialize(writer, "900");
                        return;
                    case FontWeight.Bold:
                        serializer.Serialize(writer, "bold");
                        return;
                    case FontWeight.Bolder:
                        serializer.Serialize(writer, "bolder");
                        return;
                    case FontWeight.Lighter:
                        serializer.Serialize(writer, "lighter");
                        return;
                    case FontWeight.Normal:
                        serializer.Serialize(writer, "normal");
                        return;
                }
            }
            if (value.LabelFontWeightElementArray != null)
            {
                serializer.Serialize(writer, value.LabelFontWeightElementArray);
                return;
            }
            if (value.LabelFontWeightClass != null)
            {
                serializer.Serialize(writer, value.LabelFontWeightClass);
                return;
            }
            throw new Exception("Cannot marshal type LabelFontWeightUnion");
        }

        public static readonly LabelFontWeightUnionConverter Singleton = new LabelFontWeightUnionConverter();
    }

    internal class FontWeightConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FontWeight) || t == typeof(FontWeight?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "100":
                    return FontWeight.The100;
                case "200":
                    return FontWeight.The200;
                case "300":
                    return FontWeight.The300;
                case "400":
                    return FontWeight.The400;
                case "500":
                    return FontWeight.The500;
                case "600":
                    return FontWeight.The600;
                case "700":
                    return FontWeight.The700;
                case "800":
                    return FontWeight.The800;
                case "900":
                    return FontWeight.The900;
                case "bold":
                    return FontWeight.Bold;
                case "bolder":
                    return FontWeight.Bolder;
                case "lighter":
                    return FontWeight.Lighter;
                case "normal":
                    return FontWeight.Normal;
            }
            throw new Exception("Cannot unmarshal type FontWeight");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FontWeight)untypedValue;
            switch (value)
            {
                case FontWeight.The100:
                    serializer.Serialize(writer, "100");
                    return;
                case FontWeight.The200:
                    serializer.Serialize(writer, "200");
                    return;
                case FontWeight.The300:
                    serializer.Serialize(writer, "300");
                    return;
                case FontWeight.The400:
                    serializer.Serialize(writer, "400");
                    return;
                case FontWeight.The500:
                    serializer.Serialize(writer, "500");
                    return;
                case FontWeight.The600:
                    serializer.Serialize(writer, "600");
                    return;
                case FontWeight.The700:
                    serializer.Serialize(writer, "700");
                    return;
                case FontWeight.The800:
                    serializer.Serialize(writer, "800");
                    return;
                case FontWeight.The900:
                    serializer.Serialize(writer, "900");
                    return;
                case FontWeight.Bold:
                    serializer.Serialize(writer, "bold");
                    return;
                case FontWeight.Bolder:
                    serializer.Serialize(writer, "bolder");
                    return;
                case FontWeight.Lighter:
                    serializer.Serialize(writer, "lighter");
                    return;
                case FontWeight.Normal:
                    serializer.Serialize(writer, "normal");
                    return;
            }
            throw new Exception("Cannot marshal type FontWeight");
        }

        public static readonly FontWeightConverter Singleton = new FontWeightConverter();
    }

    internal class LabelOverlapConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LabelOverlap) || t == typeof(LabelOverlap?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new LabelOverlap { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "greedy":
                            return new LabelOverlap { Enum = LabelOverlapEnum.Greedy };
                        case "parity":
                            return new LabelOverlap { Enum = LabelOverlapEnum.Parity };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new LabelOverlap { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type LabelOverlap");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (LabelOverlap)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case LabelOverlapEnum.Greedy:
                        serializer.Serialize(writer, "greedy");
                        return;
                    case LabelOverlapEnum.Parity:
                        serializer.Serialize(writer, "parity");
                        return;
                }
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type LabelOverlap");
        }

        public static readonly LabelOverlapConverter Singleton = new LabelOverlapConverter();
    }

    internal class LabelOverlapEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LabelOverlapEnum) || t == typeof(LabelOverlapEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "greedy":
                    return LabelOverlapEnum.Greedy;
                case "parity":
                    return LabelOverlapEnum.Parity;
            }
            throw new Exception("Cannot unmarshal type LabelOverlapEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (LabelOverlapEnum)untypedValue;
            switch (value)
            {
                case LabelOverlapEnum.Greedy:
                    serializer.Serialize(writer, "greedy");
                    return;
                case LabelOverlapEnum.Parity:
                    serializer.Serialize(writer, "parity");
                    return;
            }
            throw new Exception("Cannot marshal type LabelOverlapEnum");
        }

        public static readonly LabelOverlapEnumConverter Singleton = new LabelOverlapEnumConverter();
    }

    internal class AxeOrientConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AxeOrient) || t == typeof(AxeOrient?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "bottom":
                            return new AxeOrient { Enum = TitleOrientEnum.Bottom };
                        case "left":
                            return new AxeOrient { Enum = TitleOrientEnum.Left };
                        case "right":
                            return new AxeOrient { Enum = TitleOrientEnum.Right };
                        case "top":
                            return new AxeOrient { Enum = TitleOrientEnum.Top };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new AxeOrient { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type AxeOrient");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (AxeOrient)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case TitleOrientEnum.Bottom:
                        serializer.Serialize(writer, "bottom");
                        return;
                    case TitleOrientEnum.Left:
                        serializer.Serialize(writer, "left");
                        return;
                    case TitleOrientEnum.Right:
                        serializer.Serialize(writer, "right");
                        return;
                    case TitleOrientEnum.Top:
                        serializer.Serialize(writer, "top");
                        return;
                }
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type AxeOrient");
        }

        public static readonly AxeOrientConverter Singleton = new AxeOrientConverter();
    }

    internal class TitleOrientEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TitleOrientEnum) || t == typeof(TitleOrientEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "bottom":
                    return TitleOrientEnum.Bottom;
                case "left":
                    return TitleOrientEnum.Left;
                case "right":
                    return TitleOrientEnum.Right;
                case "top":
                    return TitleOrientEnum.Top;
            }
            throw new Exception("Cannot unmarshal type TitleOrientEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TitleOrientEnum)untypedValue;
            switch (value)
            {
                case TitleOrientEnum.Bottom:
                    serializer.Serialize(writer, "bottom");
                    return;
                case TitleOrientEnum.Left:
                    serializer.Serialize(writer, "left");
                    return;
                case TitleOrientEnum.Right:
                    serializer.Serialize(writer, "right");
                    return;
                case TitleOrientEnum.Top:
                    serializer.Serialize(writer, "top");
                    return;
            }
            throw new Exception("Cannot marshal type TitleOrientEnum");
        }

        public static readonly TitleOrientEnumConverter Singleton = new TitleOrientEnumConverter();
    }

    internal class TickBandConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TickBand) || t == typeof(TickBand?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "center":
                            return new TickBand { Enum = TickBandEnum.Center };
                        case "extent":
                            return new TickBand { Enum = TickBandEnum.Extent };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new TickBand { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type TickBand");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TickBand)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case TickBandEnum.Center:
                        serializer.Serialize(writer, "center");
                        return;
                    case TickBandEnum.Extent:
                        serializer.Serialize(writer, "extent");
                        return;
                }
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type TickBand");
        }

        public static readonly TickBandConverter Singleton = new TickBandConverter();
    }

    internal class TickBandEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TickBandEnum) || t == typeof(TickBandEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "center":
                    return TickBandEnum.Center;
                case "extent":
                    return TickBandEnum.Extent;
            }
            throw new Exception("Cannot unmarshal type TickBandEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TickBandEnum)untypedValue;
            switch (value)
            {
                case TickBandEnum.Center:
                    serializer.Serialize(writer, "center");
                    return;
                case TickBandEnum.Extent:
                    serializer.Serialize(writer, "extent");
                    return;
            }
            throw new Exception("Cannot marshal type TickBandEnum");
        }

        public static readonly TickBandEnumConverter Singleton = new TickBandEnumConverter();
    }

    internal class TickCountConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TickCount) || t == typeof(TickCount?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new TickCount { Double = doubleValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "day":
                            return new TickCount { Enum = TickCountEnum.Day };
                        case "hour":
                            return new TickCount { Enum = TickCountEnum.Hour };
                        case "millisecond":
                            return new TickCount { Enum = TickCountEnum.Millisecond };
                        case "minute":
                            return new TickCount { Enum = TickCountEnum.Minute };
                        case "month":
                            return new TickCount { Enum = TickCountEnum.Month };
                        case "second":
                            return new TickCount { Enum = TickCountEnum.Second };
                        case "week":
                            return new TickCount { Enum = TickCountEnum.Week };
                        case "year":
                            return new TickCount { Enum = TickCountEnum.Year };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<TickCountSignalRef>(reader);
                    return new TickCount { TickCountSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type TickCount");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TickCount)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case TickCountEnum.Day:
                        serializer.Serialize(writer, "day");
                        return;
                    case TickCountEnum.Hour:
                        serializer.Serialize(writer, "hour");
                        return;
                    case TickCountEnum.Millisecond:
                        serializer.Serialize(writer, "millisecond");
                        return;
                    case TickCountEnum.Minute:
                        serializer.Serialize(writer, "minute");
                        return;
                    case TickCountEnum.Month:
                        serializer.Serialize(writer, "month");
                        return;
                    case TickCountEnum.Second:
                        serializer.Serialize(writer, "second");
                        return;
                    case TickCountEnum.Week:
                        serializer.Serialize(writer, "week");
                        return;
                    case TickCountEnum.Year:
                        serializer.Serialize(writer, "year");
                        return;
                }
            }
            if (value.TickCountSignalRef != null)
            {
                serializer.Serialize(writer, value.TickCountSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type TickCount");
        }

        public static readonly TickCountConverter Singleton = new TickCountConverter();
    }

    internal class IntervalConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Interval) || t == typeof(Interval?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "day":
                            return new Interval { Enum = TickCountEnum.Day };
                        case "hour":
                            return new Interval { Enum = TickCountEnum.Hour };
                        case "millisecond":
                            return new Interval { Enum = TickCountEnum.Millisecond };
                        case "minute":
                            return new Interval { Enum = TickCountEnum.Minute };
                        case "month":
                            return new Interval { Enum = TickCountEnum.Month };
                        case "second":
                            return new Interval { Enum = TickCountEnum.Second };
                        case "week":
                            return new Interval { Enum = TickCountEnum.Week };
                        case "year":
                            return new Interval { Enum = TickCountEnum.Year };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new Interval { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type Interval");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Interval)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case TickCountEnum.Day:
                        serializer.Serialize(writer, "day");
                        return;
                    case TickCountEnum.Hour:
                        serializer.Serialize(writer, "hour");
                        return;
                    case TickCountEnum.Millisecond:
                        serializer.Serialize(writer, "millisecond");
                        return;
                    case TickCountEnum.Minute:
                        serializer.Serialize(writer, "minute");
                        return;
                    case TickCountEnum.Month:
                        serializer.Serialize(writer, "month");
                        return;
                    case TickCountEnum.Second:
                        serializer.Serialize(writer, "second");
                        return;
                    case TickCountEnum.Week:
                        serializer.Serialize(writer, "week");
                        return;
                    case TickCountEnum.Year:
                        serializer.Serialize(writer, "year");
                        return;
                }
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type Interval");
        }

        public static readonly IntervalConverter Singleton = new IntervalConverter();
    }

    internal class TickCountEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TickCountEnum) || t == typeof(TickCountEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "day":
                    return TickCountEnum.Day;
                case "hour":
                    return TickCountEnum.Hour;
                case "millisecond":
                    return TickCountEnum.Millisecond;
                case "minute":
                    return TickCountEnum.Minute;
                case "month":
                    return TickCountEnum.Month;
                case "second":
                    return TickCountEnum.Second;
                case "week":
                    return TickCountEnum.Week;
                case "year":
                    return TickCountEnum.Year;
            }
            throw new Exception("Cannot unmarshal type TickCountEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TickCountEnum)untypedValue;
            switch (value)
            {
                case TickCountEnum.Day:
                    serializer.Serialize(writer, "day");
                    return;
                case TickCountEnum.Hour:
                    serializer.Serialize(writer, "hour");
                    return;
                case TickCountEnum.Millisecond:
                    serializer.Serialize(writer, "millisecond");
                    return;
                case TickCountEnum.Minute:
                    serializer.Serialize(writer, "minute");
                    return;
                case TickCountEnum.Month:
                    serializer.Serialize(writer, "month");
                    return;
                case TickCountEnum.Second:
                    serializer.Serialize(writer, "second");
                    return;
                case TickCountEnum.Week:
                    serializer.Serialize(writer, "week");
                    return;
                case TickCountEnum.Year:
                    serializer.Serialize(writer, "year");
                    return;
            }
            throw new Exception("Cannot marshal type TickCountEnum");
        }

        public static readonly TickCountEnumConverter Singleton = new TickCountEnumConverter();
    }

    internal class TickExtraUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TickExtraUnion) || t == typeof(TickExtraUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new TickExtraUnion { Bool = boolValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new TickExtraUnion { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type TickExtraUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TickExtraUnion)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type TickExtraUnion");
        }

        public static readonly TickExtraUnionConverter Singleton = new TickExtraUnionConverter();
    }

    internal class TickRoundUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TickRoundUnion) || t == typeof(TickRoundUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new TickRoundUnion { Bool = boolValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<TickRoundClass>(reader);
                    return new TickRoundUnion { TickRoundClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<TickRoundElement[]>(reader);
                    return new TickRoundUnion { TickRoundElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type TickRoundUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TickRoundUnion)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.TickRoundElementArray != null)
            {
                serializer.Serialize(writer, value.TickRoundElementArray);
                return;
            }
            if (value.TickRoundClass != null)
            {
                serializer.Serialize(writer, value.TickRoundClass);
                return;
            }
            throw new Exception("Cannot marshal type TickRoundUnion");
        }

        public static readonly TickRoundUnionConverter Singleton = new TickRoundUnionConverter();
    }

    internal class TextOrSignalConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TextOrSignal) || t == typeof(TextOrSignal?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new TextOrSignal { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new TextOrSignal { FormatTypeSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<string[]>(reader);
                    return new TextOrSignal { StringArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type TextOrSignal");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TextOrSignal)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.StringArray != null)
            {
                serializer.Serialize(writer, value.StringArray);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type TextOrSignal");
        }

        public static readonly TextOrSignalConverter Singleton = new TextOrSignalConverter();
    }

    internal class TitleAnchorUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TitleAnchorUnion) || t == typeof(TitleAnchorUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new TitleAnchorUnion { };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "end":
                            return new TitleAnchorUnion { Enum = Anchor.End };
                        case "middle":
                            return new TitleAnchorUnion { Enum = Anchor.Middle };
                        case "start":
                            return new TitleAnchorUnion { Enum = Anchor.Start };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<AnchorValue>(reader);
                    return new TitleAnchorUnion { AnchorValue = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<TitleAnchorElement[]>(reader);
                    return new TitleAnchorUnion { TitleAnchorElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type TitleAnchorUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TitleAnchorUnion)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case Anchor.End:
                        serializer.Serialize(writer, "end");
                        return;
                    case Anchor.Middle:
                        serializer.Serialize(writer, "middle");
                        return;
                    case Anchor.Start:
                        serializer.Serialize(writer, "start");
                        return;
                }
            }
            if (value.TitleAnchorElementArray != null)
            {
                serializer.Serialize(writer, value.TitleAnchorElementArray);
                return;
            }
            if (value.AnchorValue != null)
            {
                serializer.Serialize(writer, value.AnchorValue);
                return;
            }
            throw new Exception("Cannot marshal type TitleAnchorUnion");
        }

        public static readonly TitleAnchorUnionConverter Singleton = new TitleAnchorUnionConverter();
    }

    internal class AnchorConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Anchor) || t == typeof(Anchor?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "end":
                    return Anchor.End;
                case "middle":
                    return Anchor.Middle;
                case "start":
                    return Anchor.Start;
            }
            throw new Exception("Cannot unmarshal type Anchor");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Anchor)untypedValue;
            switch (value)
            {
                case Anchor.End:
                    serializer.Serialize(writer, "end");
                    return;
                case Anchor.Middle:
                    serializer.Serialize(writer, "middle");
                    return;
                case Anchor.Start:
                    serializer.Serialize(writer, "start");
                    return;
            }
            throw new Exception("Cannot marshal type Anchor");
        }

        public static readonly AnchorConverter Singleton = new AnchorConverter();
    }

    internal class ArrayOrSignalConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ArrayOrSignal) || t == typeof(ArrayOrSignal?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new ArrayOrSignal { FormatTypeSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<object[]>(reader);
                    return new ArrayOrSignal { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type ArrayOrSignal");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ArrayOrSignal)untypedValue;
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type ArrayOrSignal");
        }

        public static readonly ArrayOrSignalConverter Singleton = new ArrayOrSignalConverter();
    }

    internal class BackgroundElementConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BackgroundElement) || t == typeof(BackgroundElement?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new BackgroundElement { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new BackgroundElement { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type BackgroundElement");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (BackgroundElement)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type BackgroundElement");
        }

        public static readonly BackgroundElementConverter Singleton = new BackgroundElementConverter();
    }

    internal class FilterConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Filter) || t == typeof(Filter?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "exterior":
                    return Filter.Exterior;
                case "interior":
                    return Filter.Interior;
            }
            throw new Exception("Cannot unmarshal type Filter");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Filter)untypedValue;
            switch (value)
            {
                case Filter.Exterior:
                    serializer.Serialize(writer, "exterior");
                    return;
                case Filter.Interior:
                    serializer.Serialize(writer, "interior");
                    return;
            }
            throw new Exception("Cannot marshal type Filter");
        }

        public static readonly FilterConverter Singleton = new FilterConverter();
    }

    internal class ParseUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ParseUnion) || t == typeof(ParseUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    if (stringValue == "auto")
                    {
                        return new ParseUnion { Enum = ParseEnum.Auto };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<ParseSignalRef>(reader);
                    return new ParseUnion { ParseSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type ParseUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ParseUnion)untypedValue;
            if (value.Enum != null)
            {
                if (value.Enum == ParseEnum.Auto)
                {
                    serializer.Serialize(writer, "auto");
                    return;
                }
            }
            if (value.ParseSignalRef != null)
            {
                serializer.Serialize(writer, value.ParseSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type ParseUnion");
        }

        public static readonly ParseUnionConverter Singleton = new ParseUnionConverter();
    }

    internal class ParseEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ParseEnum) || t == typeof(ParseEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "auto")
            {
                return ParseEnum.Auto;
            }
            throw new Exception("Cannot unmarshal type ParseEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ParseEnum)untypedValue;
            if (value == ParseEnum.Auto)
            {
                serializer.Serialize(writer, "auto");
                return;
            }
            throw new Exception("Cannot marshal type ParseEnum");
        }

        public static readonly ParseEnumConverter Singleton = new ParseEnumConverter();
    }

    internal class RemoveConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Remove) || t == typeof(Remove?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new Remove { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Remove { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type Remove");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Remove)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type Remove");
        }

        public static readonly RemoveConverter Singleton = new RemoveConverter();
    }

    internal class ParamsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Params) || t == typeof(Params?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new Params { FormatTypeSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<AggregateParamElement[]>(reader);
                    return new Params { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Params");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Params)untypedValue;
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type Params");
        }

        public static readonly ParamsConverter Singleton = new ParamsConverter();
    }

    internal class AggregateParamElementConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AggregateParamElement) || t == typeof(AggregateParamElement?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new AggregateParamElement { };
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new AggregateParamElement { Double = doubleValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new AggregateParamElement { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type AggregateParamElement");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (AggregateParamElement)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type AggregateParamElement");
        }

        public static readonly AggregateParamElementConverter Singleton = new AggregateParamElementConverter();
    }

    internal class AnchorUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AnchorUnion) || t == typeof(AnchorUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new AnchorUnion { Double = doubleValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new AnchorUnion { FormatTypeSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<BackgroundElement[]>(reader);
                    return new AnchorUnion { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type AnchorUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (AnchorUnion)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type AnchorUnion");
        }

        public static readonly AnchorUnionConverter Singleton = new AnchorUnionConverter();
    }

    internal class TransformAsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TransformAs) || t == typeof(TransformAs?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new TransformAs { };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new TransformAs { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new TransformAs { FormatTypeSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<AElement[]>(reader);
                    return new TransformAs { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type TransformAs");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TransformAs)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type TransformAs");
        }

        public static readonly TransformAsConverter Singleton = new TransformAsConverter();
    }

    internal class AElementConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AElement) || t == typeof(AElement?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new AElement { };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new AElement { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new AElement { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type AElement");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (AElement)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type AElement");
        }

        public static readonly AElementConverter Singleton = new AElementConverter();
    }

    internal class AvoidMarksConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AvoidMarks) || t == typeof(AvoidMarks?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new AvoidMarks { FormatTypeSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<string[]>(reader);
                    return new AvoidMarks { StringArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type AvoidMarks");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (AvoidMarks)untypedValue;
            if (value.StringArray != null)
            {
                serializer.Serialize(writer, value.StringArray);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type AvoidMarks");
        }

        public static readonly AvoidMarksConverter Singleton = new AvoidMarksConverter();
    }

    internal class StepsUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(StepsUnion) || t == typeof(StepsUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new StepsUnion { Double = doubleValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new StepsUnion { FormatTypeSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<HeightElement[]>(reader);
                    return new StepsUnion { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type StepsUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (StepsUnion)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type StepsUnion");
        }

        public static readonly StepsUnionConverter Singleton = new StepsUnionConverter();
    }

    internal class CaseUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CaseUnion) || t == typeof(CaseUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "lower":
                            return new CaseUnion { Enum = CaseEnum.Lower };
                        case "mixed":
                            return new CaseUnion { Enum = CaseEnum.Mixed };
                        case "upper":
                            return new CaseUnion { Enum = CaseEnum.Upper };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new CaseUnion { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type CaseUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (CaseUnion)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case CaseEnum.Lower:
                        serializer.Serialize(writer, "lower");
                        return;
                    case CaseEnum.Mixed:
                        serializer.Serialize(writer, "mixed");
                        return;
                    case CaseEnum.Upper:
                        serializer.Serialize(writer, "upper");
                        return;
                }
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type CaseUnion");
        }

        public static readonly CaseUnionConverter Singleton = new CaseUnionConverter();
    }

    internal class CaseEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CaseEnum) || t == typeof(CaseEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "lower":
                    return CaseEnum.Lower;
                case "mixed":
                    return CaseEnum.Mixed;
                case "upper":
                    return CaseEnum.Upper;
            }
            throw new Exception("Cannot unmarshal type CaseEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CaseEnum)untypedValue;
            switch (value)
            {
                case CaseEnum.Lower:
                    serializer.Serialize(writer, "lower");
                    return;
                case CaseEnum.Mixed:
                    serializer.Serialize(writer, "mixed");
                    return;
                case CaseEnum.Upper:
                    serializer.Serialize(writer, "upper");
                    return;
            }
            throw new Exception("Cannot marshal type CaseEnum");
        }

        public static readonly CaseEnumConverter Singleton = new CaseEnumConverter();
    }

    internal class ColorElementConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ColorElement) || t == typeof(ColorElement?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new ColorElement { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<ColorSignalRef>(reader);
                    return new ColorElement { ColorSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type ColorElement");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ColorElement)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.ColorSignalRef != null)
            {
                serializer.Serialize(writer, value.ColorSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type ColorElement");
        }

        public static readonly ColorElementConverter Singleton = new ColorElementConverter();
    }

    internal class FunctionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Function) || t == typeof(Function?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "kde":
                    return Function.Kde;
                case "lognormal":
                    return Function.Lognormal;
                case "mixture":
                    return Function.Mixture;
                case "normal":
                    return Function.Normal;
                case "uniform":
                    return Function.Uniform;
            }
            throw new Exception("Cannot unmarshal type Function");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Function)untypedValue;
            switch (value)
            {
                case Function.Kde:
                    serializer.Serialize(writer, "kde");
                    return;
                case Function.Lognormal:
                    serializer.Serialize(writer, "lognormal");
                    return;
                case Function.Mixture:
                    serializer.Serialize(writer, "mixture");
                    return;
                case Function.Normal:
                    serializer.Serialize(writer, "normal");
                    return;
                case Function.Uniform:
                    serializer.Serialize(writer, "uniform");
                    return;
            }
            throw new Exception("Cannot marshal type Function");
        }

        public static readonly FunctionConverter Singleton = new FunctionConverter();
    }

    internal class CenterElementConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CenterElement) || t == typeof(CenterElement?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new CenterElement { FormatTypeSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<HeightElement[]>(reader);
                    return new CenterElement { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type CenterElement");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (CenterElement)untypedValue;
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type CenterElement");
        }

        public static readonly CenterElementConverter Singleton = new CenterElementConverter();
    }

    internal class FieldsUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FieldsUnion) || t == typeof(FieldsUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new FieldsUnion { FormatTypeSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<FieldsField[]>(reader);
                    return new FieldsUnion { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type FieldsUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (FieldsUnion)untypedValue;
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type FieldsUnion");
        }

        public static readonly FieldsUnionConverter Singleton = new FieldsUnionConverter();
    }

    internal class FieldsFieldConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FieldsField) || t == typeof(FieldsField?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new FieldsField { };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new FieldsField { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<TentacledSignalRef>(reader);
                    return new FieldsField { TentacledSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type FieldsField");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (FieldsField)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.TentacledSignalRef != null)
            {
                serializer.Serialize(writer, value.TentacledSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type FieldsField");
        }

        public static readonly FieldsFieldConverter Singleton = new FieldsFieldConverter();
    }

    internal class RadiusConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Radius) || t == typeof(Radius?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Radius { Double = doubleValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FontSizeSignalRef>(reader);
                    return new Radius { FontSizeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type Radius");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Radius)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.FontSizeSignalRef != null)
            {
                serializer.Serialize(writer, value.FontSizeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type Radius");
        }

        public static readonly RadiusConverter Singleton = new RadiusConverter();
    }

    internal class FontSizeRangeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FontSizeRange) || t == typeof(FontSizeRange?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new FontSizeRange { };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new FontSizeRange { FormatTypeSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<HeightElement[]>(reader);
                    return new FontSizeRange { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type FontSizeRange");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (FontSizeRange)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type FontSizeRange");
        }

        public static readonly FontSizeRangeConverter Singleton = new FontSizeRangeConverter();
    }

    internal class ForceEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ForceEnum) || t == typeof(ForceEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "center":
                    return ForceEnum.Center;
                case "collide":
                    return ForceEnum.Collide;
                case "link":
                    return ForceEnum.Link;
                case "nbody":
                    return ForceEnum.Nbody;
                case "x":
                    return ForceEnum.X;
                case "y":
                    return ForceEnum.Y;
            }
            throw new Exception("Cannot unmarshal type ForceEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ForceEnum)untypedValue;
            switch (value)
            {
                case ForceEnum.Center:
                    serializer.Serialize(writer, "center");
                    return;
                case ForceEnum.Collide:
                    serializer.Serialize(writer, "collide");
                    return;
                case ForceEnum.Link:
                    serializer.Serialize(writer, "link");
                    return;
                case ForceEnum.Nbody:
                    serializer.Serialize(writer, "nbody");
                    return;
                case ForceEnum.X:
                    serializer.Serialize(writer, "x");
                    return;
                case ForceEnum.Y:
                    serializer.Serialize(writer, "y");
                    return;
            }
            throw new Exception("Cannot marshal type ForceEnum");
        }

        public static readonly ForceEnumConverter Singleton = new ForceEnumConverter();
    }

    internal class StrengthUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(StrengthUnion) || t == typeof(StrengthUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new StrengthUnion { Double = doubleValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<StrengthSignalRef>(reader);
                    return new StrengthUnion { StrengthSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type StrengthUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (StrengthUnion)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.StrengthSignalRef != null)
            {
                serializer.Serialize(writer, value.StrengthSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type StrengthUnion");
        }

        public static readonly StrengthUnionConverter Singleton = new StrengthUnionConverter();
    }

    internal class XUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(XUnion) || t == typeof(XUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new XUnion { Double = doubleValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new XUnion { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<StickySignalRef>(reader);
                    return new XUnion { StickySignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type XUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (XUnion)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.StickySignalRef != null)
            {
                serializer.Serialize(writer, value.StickySignalRef);
                return;
            }
            throw new Exception("Cannot marshal type XUnion");
        }

        public static readonly XUnionConverter Singleton = new XUnionConverter();
    }

    internal class GroupbyUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(GroupbyUnion) || t == typeof(GroupbyUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new GroupbyUnion { FormatTypeSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<ColorElement[]>(reader);
                    return new GroupbyUnion { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type GroupbyUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (GroupbyUnion)untypedValue;
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type GroupbyUnion");
        }

        public static readonly GroupbyUnionConverter Singleton = new GroupbyUnionConverter();
    }

    internal class TransformOffsetConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TransformOffset) || t == typeof(TransformOffset?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "center":
                            return new TransformOffset { Enum = OffsetEnum.Center };
                        case "normalize":
                            return new TransformOffset { Enum = OffsetEnum.Normalize };
                        case "zero":
                            return new TransformOffset { Enum = OffsetEnum.Zero };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new TransformOffset { FormatTypeSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<HeightElement[]>(reader);
                    return new TransformOffset { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type TransformOffset");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TransformOffset)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case OffsetEnum.Center:
                        serializer.Serialize(writer, "center");
                        return;
                    case OffsetEnum.Normalize:
                        serializer.Serialize(writer, "normalize");
                        return;
                    case OffsetEnum.Zero:
                        serializer.Serialize(writer, "zero");
                        return;
                }
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type TransformOffset");
        }

        public static readonly TransformOffsetConverter Singleton = new TransformOffsetConverter();
    }

    internal class OffsetEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OffsetEnum) || t == typeof(OffsetEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "center":
                    return OffsetEnum.Center;
                case "normalize":
                    return OffsetEnum.Normalize;
                case "zero":
                    return OffsetEnum.Zero;
            }
            throw new Exception("Cannot unmarshal type OffsetEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (OffsetEnum)untypedValue;
            switch (value)
            {
                case OffsetEnum.Center:
                    serializer.Serialize(writer, "center");
                    return;
                case OffsetEnum.Normalize:
                    serializer.Serialize(writer, "normalize");
                    return;
                case OffsetEnum.Zero:
                    serializer.Serialize(writer, "zero");
                    return;
            }
            throw new Exception("Cannot marshal type OffsetEnum");
        }

        public static readonly OffsetEnumConverter Singleton = new OffsetEnumConverter();
    }

    internal class TransformOpConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TransformOp) || t == typeof(TransformOp?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "argmax":
                            return new TransformOp { Enum = PurpleOp.Argmax };
                        case "argmin":
                            return new TransformOp { Enum = PurpleOp.Argmin };
                        case "average":
                            return new TransformOp { Enum = PurpleOp.Average };
                        case "ci0":
                            return new TransformOp { Enum = PurpleOp.Ci0 };
                        case "ci1":
                            return new TransformOp { Enum = PurpleOp.Ci1 };
                        case "count":
                            return new TransformOp { Enum = PurpleOp.Count };
                        case "distinct":
                            return new TransformOp { Enum = PurpleOp.Distinct };
                        case "exponential":
                            return new TransformOp { Enum = PurpleOp.Exponential };
                        case "exponentialb":
                            return new TransformOp { Enum = PurpleOp.Exponentialb };
                        case "max":
                            return new TransformOp { Enum = PurpleOp.Max };
                        case "mean":
                            return new TransformOp { Enum = PurpleOp.Mean };
                        case "median":
                            return new TransformOp { Enum = PurpleOp.Median };
                        case "min":
                            return new TransformOp { Enum = PurpleOp.Min };
                        case "missing":
                            return new TransformOp { Enum = PurpleOp.Missing };
                        case "product":
                            return new TransformOp { Enum = PurpleOp.Product };
                        case "q1":
                            return new TransformOp { Enum = PurpleOp.Q1 };
                        case "q3":
                            return new TransformOp { Enum = PurpleOp.Q3 };
                        case "stderr":
                            return new TransformOp { Enum = PurpleOp.Stderr };
                        case "stdev":
                            return new TransformOp { Enum = PurpleOp.Stdev };
                        case "stdevp":
                            return new TransformOp { Enum = PurpleOp.Stdevp };
                        case "sum":
                            return new TransformOp { Enum = PurpleOp.Sum };
                        case "valid":
                            return new TransformOp { Enum = PurpleOp.Valid };
                        case "values":
                            return new TransformOp { Enum = PurpleOp.Values };
                        case "variance":
                            return new TransformOp { Enum = PurpleOp.Variance };
                        case "variancep":
                            return new TransformOp { Enum = PurpleOp.Variancep };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new TransformOp { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type TransformOp");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TransformOp)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case PurpleOp.Argmax:
                        serializer.Serialize(writer, "argmax");
                        return;
                    case PurpleOp.Argmin:
                        serializer.Serialize(writer, "argmin");
                        return;
                    case PurpleOp.Average:
                        serializer.Serialize(writer, "average");
                        return;
                    case PurpleOp.Ci0:
                        serializer.Serialize(writer, "ci0");
                        return;
                    case PurpleOp.Ci1:
                        serializer.Serialize(writer, "ci1");
                        return;
                    case PurpleOp.Count:
                        serializer.Serialize(writer, "count");
                        return;
                    case PurpleOp.Distinct:
                        serializer.Serialize(writer, "distinct");
                        return;
                    case PurpleOp.Exponential:
                        serializer.Serialize(writer, "exponential");
                        return;
                    case PurpleOp.Exponentialb:
                        serializer.Serialize(writer, "exponentialb");
                        return;
                    case PurpleOp.Max:
                        serializer.Serialize(writer, "max");
                        return;
                    case PurpleOp.Mean:
                        serializer.Serialize(writer, "mean");
                        return;
                    case PurpleOp.Median:
                        serializer.Serialize(writer, "median");
                        return;
                    case PurpleOp.Min:
                        serializer.Serialize(writer, "min");
                        return;
                    case PurpleOp.Missing:
                        serializer.Serialize(writer, "missing");
                        return;
                    case PurpleOp.Product:
                        serializer.Serialize(writer, "product");
                        return;
                    case PurpleOp.Q1:
                        serializer.Serialize(writer, "q1");
                        return;
                    case PurpleOp.Q3:
                        serializer.Serialize(writer, "q3");
                        return;
                    case PurpleOp.Stderr:
                        serializer.Serialize(writer, "stderr");
                        return;
                    case PurpleOp.Stdev:
                        serializer.Serialize(writer, "stdev");
                        return;
                    case PurpleOp.Stdevp:
                        serializer.Serialize(writer, "stdevp");
                        return;
                    case PurpleOp.Sum:
                        serializer.Serialize(writer, "sum");
                        return;
                    case PurpleOp.Valid:
                        serializer.Serialize(writer, "valid");
                        return;
                    case PurpleOp.Values:
                        serializer.Serialize(writer, "values");
                        return;
                    case PurpleOp.Variance:
                        serializer.Serialize(writer, "variance");
                        return;
                    case PurpleOp.Variancep:
                        serializer.Serialize(writer, "variancep");
                        return;
                }
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type TransformOp");
        }

        public static readonly TransformOpConverter Singleton = new TransformOpConverter();
    }

    internal class PurpleOpConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PurpleOp) || t == typeof(PurpleOp?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "argmax":
                    return PurpleOp.Argmax;
                case "argmin":
                    return PurpleOp.Argmin;
                case "average":
                    return PurpleOp.Average;
                case "ci0":
                    return PurpleOp.Ci0;
                case "ci1":
                    return PurpleOp.Ci1;
                case "count":
                    return PurpleOp.Count;
                case "distinct":
                    return PurpleOp.Distinct;
                case "exponential":
                    return PurpleOp.Exponential;
                case "exponentialb":
                    return PurpleOp.Exponentialb;
                case "max":
                    return PurpleOp.Max;
                case "mean":
                    return PurpleOp.Mean;
                case "median":
                    return PurpleOp.Median;
                case "min":
                    return PurpleOp.Min;
                case "missing":
                    return PurpleOp.Missing;
                case "product":
                    return PurpleOp.Product;
                case "q1":
                    return PurpleOp.Q1;
                case "q3":
                    return PurpleOp.Q3;
                case "stderr":
                    return PurpleOp.Stderr;
                case "stdev":
                    return PurpleOp.Stdev;
                case "stdevp":
                    return PurpleOp.Stdevp;
                case "sum":
                    return PurpleOp.Sum;
                case "valid":
                    return PurpleOp.Valid;
                case "values":
                    return PurpleOp.Values;
                case "variance":
                    return PurpleOp.Variance;
                case "variancep":
                    return PurpleOp.Variancep;
            }
            throw new Exception("Cannot unmarshal type PurpleOp");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PurpleOp)untypedValue;
            switch (value)
            {
                case PurpleOp.Argmax:
                    serializer.Serialize(writer, "argmax");
                    return;
                case PurpleOp.Argmin:
                    serializer.Serialize(writer, "argmin");
                    return;
                case PurpleOp.Average:
                    serializer.Serialize(writer, "average");
                    return;
                case PurpleOp.Ci0:
                    serializer.Serialize(writer, "ci0");
                    return;
                case PurpleOp.Ci1:
                    serializer.Serialize(writer, "ci1");
                    return;
                case PurpleOp.Count:
                    serializer.Serialize(writer, "count");
                    return;
                case PurpleOp.Distinct:
                    serializer.Serialize(writer, "distinct");
                    return;
                case PurpleOp.Exponential:
                    serializer.Serialize(writer, "exponential");
                    return;
                case PurpleOp.Exponentialb:
                    serializer.Serialize(writer, "exponentialb");
                    return;
                case PurpleOp.Max:
                    serializer.Serialize(writer, "max");
                    return;
                case PurpleOp.Mean:
                    serializer.Serialize(writer, "mean");
                    return;
                case PurpleOp.Median:
                    serializer.Serialize(writer, "median");
                    return;
                case PurpleOp.Min:
                    serializer.Serialize(writer, "min");
                    return;
                case PurpleOp.Missing:
                    serializer.Serialize(writer, "missing");
                    return;
                case PurpleOp.Product:
                    serializer.Serialize(writer, "product");
                    return;
                case PurpleOp.Q1:
                    serializer.Serialize(writer, "q1");
                    return;
                case PurpleOp.Q3:
                    serializer.Serialize(writer, "q3");
                    return;
                case PurpleOp.Stderr:
                    serializer.Serialize(writer, "stderr");
                    return;
                case PurpleOp.Stdev:
                    serializer.Serialize(writer, "stdev");
                    return;
                case PurpleOp.Stdevp:
                    serializer.Serialize(writer, "stdevp");
                    return;
                case PurpleOp.Sum:
                    serializer.Serialize(writer, "sum");
                    return;
                case PurpleOp.Valid:
                    serializer.Serialize(writer, "valid");
                    return;
                case PurpleOp.Values:
                    serializer.Serialize(writer, "values");
                    return;
                case PurpleOp.Variance:
                    serializer.Serialize(writer, "variance");
                    return;
                case PurpleOp.Variancep:
                    serializer.Serialize(writer, "variancep");
                    return;
            }
            throw new Exception("Cannot marshal type PurpleOp");
        }

        public static readonly PurpleOpConverter Singleton = new PurpleOpConverter();
    }

    internal class OpsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Ops) || t == typeof(Ops?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new Ops { FormatTypeSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<OpElement[]>(reader);
                    return new Ops { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Ops");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Ops)untypedValue;
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type Ops");
        }

        public static readonly OpsConverter Singleton = new OpsConverter();
    }

    internal class OpElementConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OpElement) || t == typeof(OpElement?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "argmax":
                            return new OpElement { Enum = FluffyOp.Argmax };
                        case "argmin":
                            return new OpElement { Enum = FluffyOp.Argmin };
                        case "average":
                            return new OpElement { Enum = FluffyOp.Average };
                        case "ci0":
                            return new OpElement { Enum = FluffyOp.Ci0 };
                        case "ci1":
                            return new OpElement { Enum = FluffyOp.Ci1 };
                        case "count":
                            return new OpElement { Enum = FluffyOp.Count };
                        case "cume_dist":
                            return new OpElement { Enum = FluffyOp.CumeDist };
                        case "dense_rank":
                            return new OpElement { Enum = FluffyOp.DenseRank };
                        case "distinct":
                            return new OpElement { Enum = FluffyOp.Distinct };
                        case "exponential":
                            return new OpElement { Enum = FluffyOp.Exponential };
                        case "exponentialb":
                            return new OpElement { Enum = FluffyOp.Exponentialb };
                        case "first_value":
                            return new OpElement { Enum = FluffyOp.FirstValue };
                        case "lag":
                            return new OpElement { Enum = FluffyOp.Lag };
                        case "last_value":
                            return new OpElement { Enum = FluffyOp.LastValue };
                        case "lead":
                            return new OpElement { Enum = FluffyOp.Lead };
                        case "max":
                            return new OpElement { Enum = FluffyOp.Max };
                        case "mean":
                            return new OpElement { Enum = FluffyOp.Mean };
                        case "median":
                            return new OpElement { Enum = FluffyOp.Median };
                        case "min":
                            return new OpElement { Enum = FluffyOp.Min };
                        case "missing":
                            return new OpElement { Enum = FluffyOp.Missing };
                        case "next_value":
                            return new OpElement { Enum = FluffyOp.NextValue };
                        case "nth_value":
                            return new OpElement { Enum = FluffyOp.NthValue };
                        case "ntile":
                            return new OpElement { Enum = FluffyOp.Ntile };
                        case "percent_rank":
                            return new OpElement { Enum = FluffyOp.PercentRank };
                        case "prev_value":
                            return new OpElement { Enum = FluffyOp.PrevValue };
                        case "product":
                            return new OpElement { Enum = FluffyOp.Product };
                        case "q1":
                            return new OpElement { Enum = FluffyOp.Q1 };
                        case "q3":
                            return new OpElement { Enum = FluffyOp.Q3 };
                        case "rank":
                            return new OpElement { Enum = FluffyOp.Rank };
                        case "row_number":
                            return new OpElement { Enum = FluffyOp.RowNumber };
                        case "stderr":
                            return new OpElement { Enum = FluffyOp.Stderr };
                        case "stdev":
                            return new OpElement { Enum = FluffyOp.Stdev };
                        case "stdevp":
                            return new OpElement { Enum = FluffyOp.Stdevp };
                        case "sum":
                            return new OpElement { Enum = FluffyOp.Sum };
                        case "valid":
                            return new OpElement { Enum = FluffyOp.Valid };
                        case "values":
                            return new OpElement { Enum = FluffyOp.Values };
                        case "variance":
                            return new OpElement { Enum = FluffyOp.Variance };
                        case "variancep":
                            return new OpElement { Enum = FluffyOp.Variancep };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new OpElement { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type OpElement");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (OpElement)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case FluffyOp.Argmax:
                        serializer.Serialize(writer, "argmax");
                        return;
                    case FluffyOp.Argmin:
                        serializer.Serialize(writer, "argmin");
                        return;
                    case FluffyOp.Average:
                        serializer.Serialize(writer, "average");
                        return;
                    case FluffyOp.Ci0:
                        serializer.Serialize(writer, "ci0");
                        return;
                    case FluffyOp.Ci1:
                        serializer.Serialize(writer, "ci1");
                        return;
                    case FluffyOp.Count:
                        serializer.Serialize(writer, "count");
                        return;
                    case FluffyOp.CumeDist:
                        serializer.Serialize(writer, "cume_dist");
                        return;
                    case FluffyOp.DenseRank:
                        serializer.Serialize(writer, "dense_rank");
                        return;
                    case FluffyOp.Distinct:
                        serializer.Serialize(writer, "distinct");
                        return;
                    case FluffyOp.Exponential:
                        serializer.Serialize(writer, "exponential");
                        return;
                    case FluffyOp.Exponentialb:
                        serializer.Serialize(writer, "exponentialb");
                        return;
                    case FluffyOp.FirstValue:
                        serializer.Serialize(writer, "first_value");
                        return;
                    case FluffyOp.Lag:
                        serializer.Serialize(writer, "lag");
                        return;
                    case FluffyOp.LastValue:
                        serializer.Serialize(writer, "last_value");
                        return;
                    case FluffyOp.Lead:
                        serializer.Serialize(writer, "lead");
                        return;
                    case FluffyOp.Max:
                        serializer.Serialize(writer, "max");
                        return;
                    case FluffyOp.Mean:
                        serializer.Serialize(writer, "mean");
                        return;
                    case FluffyOp.Median:
                        serializer.Serialize(writer, "median");
                        return;
                    case FluffyOp.Min:
                        serializer.Serialize(writer, "min");
                        return;
                    case FluffyOp.Missing:
                        serializer.Serialize(writer, "missing");
                        return;
                    case FluffyOp.NextValue:
                        serializer.Serialize(writer, "next_value");
                        return;
                    case FluffyOp.NthValue:
                        serializer.Serialize(writer, "nth_value");
                        return;
                    case FluffyOp.Ntile:
                        serializer.Serialize(writer, "ntile");
                        return;
                    case FluffyOp.PercentRank:
                        serializer.Serialize(writer, "percent_rank");
                        return;
                    case FluffyOp.PrevValue:
                        serializer.Serialize(writer, "prev_value");
                        return;
                    case FluffyOp.Product:
                        serializer.Serialize(writer, "product");
                        return;
                    case FluffyOp.Q1:
                        serializer.Serialize(writer, "q1");
                        return;
                    case FluffyOp.Q3:
                        serializer.Serialize(writer, "q3");
                        return;
                    case FluffyOp.Rank:
                        serializer.Serialize(writer, "rank");
                        return;
                    case FluffyOp.RowNumber:
                        serializer.Serialize(writer, "row_number");
                        return;
                    case FluffyOp.Stderr:
                        serializer.Serialize(writer, "stderr");
                        return;
                    case FluffyOp.Stdev:
                        serializer.Serialize(writer, "stdev");
                        return;
                    case FluffyOp.Stdevp:
                        serializer.Serialize(writer, "stdevp");
                        return;
                    case FluffyOp.Sum:
                        serializer.Serialize(writer, "sum");
                        return;
                    case FluffyOp.Valid:
                        serializer.Serialize(writer, "valid");
                        return;
                    case FluffyOp.Values:
                        serializer.Serialize(writer, "values");
                        return;
                    case FluffyOp.Variance:
                        serializer.Serialize(writer, "variance");
                        return;
                    case FluffyOp.Variancep:
                        serializer.Serialize(writer, "variancep");
                        return;
                }
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type OpElement");
        }

        public static readonly OpElementConverter Singleton = new OpElementConverter();
    }

    internal class FluffyOpConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FluffyOp) || t == typeof(FluffyOp?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "argmax":
                    return FluffyOp.Argmax;
                case "argmin":
                    return FluffyOp.Argmin;
                case "average":
                    return FluffyOp.Average;
                case "ci0":
                    return FluffyOp.Ci0;
                case "ci1":
                    return FluffyOp.Ci1;
                case "count":
                    return FluffyOp.Count;
                case "cume_dist":
                    return FluffyOp.CumeDist;
                case "dense_rank":
                    return FluffyOp.DenseRank;
                case "distinct":
                    return FluffyOp.Distinct;
                case "exponential":
                    return FluffyOp.Exponential;
                case "exponentialb":
                    return FluffyOp.Exponentialb;
                case "first_value":
                    return FluffyOp.FirstValue;
                case "lag":
                    return FluffyOp.Lag;
                case "last_value":
                    return FluffyOp.LastValue;
                case "lead":
                    return FluffyOp.Lead;
                case "max":
                    return FluffyOp.Max;
                case "mean":
                    return FluffyOp.Mean;
                case "median":
                    return FluffyOp.Median;
                case "min":
                    return FluffyOp.Min;
                case "missing":
                    return FluffyOp.Missing;
                case "next_value":
                    return FluffyOp.NextValue;
                case "nth_value":
                    return FluffyOp.NthValue;
                case "ntile":
                    return FluffyOp.Ntile;
                case "percent_rank":
                    return FluffyOp.PercentRank;
                case "prev_value":
                    return FluffyOp.PrevValue;
                case "product":
                    return FluffyOp.Product;
                case "q1":
                    return FluffyOp.Q1;
                case "q3":
                    return FluffyOp.Q3;
                case "rank":
                    return FluffyOp.Rank;
                case "row_number":
                    return FluffyOp.RowNumber;
                case "stderr":
                    return FluffyOp.Stderr;
                case "stdev":
                    return FluffyOp.Stdev;
                case "stdevp":
                    return FluffyOp.Stdevp;
                case "sum":
                    return FluffyOp.Sum;
                case "valid":
                    return FluffyOp.Valid;
                case "values":
                    return FluffyOp.Values;
                case "variance":
                    return FluffyOp.Variance;
                case "variancep":
                    return FluffyOp.Variancep;
            }
            throw new Exception("Cannot unmarshal type FluffyOp");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FluffyOp)untypedValue;
            switch (value)
            {
                case FluffyOp.Argmax:
                    serializer.Serialize(writer, "argmax");
                    return;
                case FluffyOp.Argmin:
                    serializer.Serialize(writer, "argmin");
                    return;
                case FluffyOp.Average:
                    serializer.Serialize(writer, "average");
                    return;
                case FluffyOp.Ci0:
                    serializer.Serialize(writer, "ci0");
                    return;
                case FluffyOp.Ci1:
                    serializer.Serialize(writer, "ci1");
                    return;
                case FluffyOp.Count:
                    serializer.Serialize(writer, "count");
                    return;
                case FluffyOp.CumeDist:
                    serializer.Serialize(writer, "cume_dist");
                    return;
                case FluffyOp.DenseRank:
                    serializer.Serialize(writer, "dense_rank");
                    return;
                case FluffyOp.Distinct:
                    serializer.Serialize(writer, "distinct");
                    return;
                case FluffyOp.Exponential:
                    serializer.Serialize(writer, "exponential");
                    return;
                case FluffyOp.Exponentialb:
                    serializer.Serialize(writer, "exponentialb");
                    return;
                case FluffyOp.FirstValue:
                    serializer.Serialize(writer, "first_value");
                    return;
                case FluffyOp.Lag:
                    serializer.Serialize(writer, "lag");
                    return;
                case FluffyOp.LastValue:
                    serializer.Serialize(writer, "last_value");
                    return;
                case FluffyOp.Lead:
                    serializer.Serialize(writer, "lead");
                    return;
                case FluffyOp.Max:
                    serializer.Serialize(writer, "max");
                    return;
                case FluffyOp.Mean:
                    serializer.Serialize(writer, "mean");
                    return;
                case FluffyOp.Median:
                    serializer.Serialize(writer, "median");
                    return;
                case FluffyOp.Min:
                    serializer.Serialize(writer, "min");
                    return;
                case FluffyOp.Missing:
                    serializer.Serialize(writer, "missing");
                    return;
                case FluffyOp.NextValue:
                    serializer.Serialize(writer, "next_value");
                    return;
                case FluffyOp.NthValue:
                    serializer.Serialize(writer, "nth_value");
                    return;
                case FluffyOp.Ntile:
                    serializer.Serialize(writer, "ntile");
                    return;
                case FluffyOp.PercentRank:
                    serializer.Serialize(writer, "percent_rank");
                    return;
                case FluffyOp.PrevValue:
                    serializer.Serialize(writer, "prev_value");
                    return;
                case FluffyOp.Product:
                    serializer.Serialize(writer, "product");
                    return;
                case FluffyOp.Q1:
                    serializer.Serialize(writer, "q1");
                    return;
                case FluffyOp.Q3:
                    serializer.Serialize(writer, "q3");
                    return;
                case FluffyOp.Rank:
                    serializer.Serialize(writer, "rank");
                    return;
                case FluffyOp.RowNumber:
                    serializer.Serialize(writer, "row_number");
                    return;
                case FluffyOp.Stderr:
                    serializer.Serialize(writer, "stderr");
                    return;
                case FluffyOp.Stdev:
                    serializer.Serialize(writer, "stdev");
                    return;
                case FluffyOp.Stdevp:
                    serializer.Serialize(writer, "stdevp");
                    return;
                case FluffyOp.Sum:
                    serializer.Serialize(writer, "sum");
                    return;
                case FluffyOp.Valid:
                    serializer.Serialize(writer, "valid");
                    return;
                case FluffyOp.Values:
                    serializer.Serialize(writer, "values");
                    return;
                case FluffyOp.Variance:
                    serializer.Serialize(writer, "variance");
                    return;
                case FluffyOp.Variancep:
                    serializer.Serialize(writer, "variancep");
                    return;
            }
            throw new Exception("Cannot marshal type FluffyOp");
        }

        public static readonly FluffyOpConverter Singleton = new FluffyOpConverter();
    }

    internal class TransformOrientConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TransformOrient) || t == typeof(TransformOrient?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "horizontal":
                            return new TransformOrient { Enum = PurpleOrient.Horizontal };
                        case "radial":
                            return new TransformOrient { Enum = PurpleOrient.Radial };
                        case "vertical":
                            return new TransformOrient { Enum = PurpleOrient.Vertical };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new TransformOrient { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type TransformOrient");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TransformOrient)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case PurpleOrient.Horizontal:
                        serializer.Serialize(writer, "horizontal");
                        return;
                    case PurpleOrient.Radial:
                        serializer.Serialize(writer, "radial");
                        return;
                    case PurpleOrient.Vertical:
                        serializer.Serialize(writer, "vertical");
                        return;
                }
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type TransformOrient");
        }

        public static readonly TransformOrientConverter Singleton = new TransformOrientConverter();
    }

    internal class PurpleOrientConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PurpleOrient) || t == typeof(PurpleOrient?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "horizontal":
                    return PurpleOrient.Horizontal;
                case "radial":
                    return PurpleOrient.Radial;
                case "vertical":
                    return PurpleOrient.Vertical;
            }
            throw new Exception("Cannot unmarshal type PurpleOrient");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PurpleOrient)untypedValue;
            switch (value)
            {
                case PurpleOrient.Horizontal:
                    serializer.Serialize(writer, "horizontal");
                    return;
                case PurpleOrient.Radial:
                    serializer.Serialize(writer, "radial");
                    return;
                case PurpleOrient.Vertical:
                    serializer.Serialize(writer, "vertical");
                    return;
            }
            throw new Exception("Cannot marshal type PurpleOrient");
        }

        public static readonly PurpleOrientConverter Singleton = new PurpleOrientConverter();
    }

    internal class TransformPaddingConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TransformPadding) || t == typeof(TransformPadding?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new TransformPadding { };
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new TransformPadding { Double = doubleValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<PaddingExpr>(reader);
                    return new TransformPadding { PaddingExpr = objectValue };
            }
            throw new Exception("Cannot unmarshal type TransformPadding");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TransformPadding)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.PaddingExpr != null)
            {
                serializer.Serialize(writer, value.PaddingExpr);
                return;
            }
            throw new Exception("Cannot marshal type TransformPadding");
        }

        public static readonly TransformPaddingConverter Singleton = new TransformPaddingConverter();
    }

    internal class ParamsUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ParamsUnion) || t == typeof(ParamsUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new ParamsUnion { Bool = boolValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new ParamsUnion { FormatTypeSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<AggregateParamElement[]>(reader);
                    return new ParamsUnion { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type ParamsUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ParamsUnion)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type ParamsUnion");
        }

        public static readonly ParamsUnionConverter Singleton = new ParamsUnionConverter();
    }

    internal class ResolveUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ResolveUnion) || t == typeof(ResolveUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "independent":
                            return new ResolveUnion { Enum = ResolveEnum.Independent };
                        case "shared":
                            return new ResolveUnion { Enum = ResolveEnum.Shared };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new ResolveUnion { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type ResolveUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ResolveUnion)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case ResolveEnum.Independent:
                        serializer.Serialize(writer, "independent");
                        return;
                    case ResolveEnum.Shared:
                        serializer.Serialize(writer, "shared");
                        return;
                }
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type ResolveUnion");
        }

        public static readonly ResolveUnionConverter Singleton = new ResolveUnionConverter();
    }

    internal class ResolveEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ResolveEnum) || t == typeof(ResolveEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "independent":
                    return ResolveEnum.Independent;
                case "shared":
                    return ResolveEnum.Shared;
            }
            throw new Exception("Cannot unmarshal type ResolveEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ResolveEnum)untypedValue;
            switch (value)
            {
                case ResolveEnum.Independent:
                    serializer.Serialize(writer, "independent");
                    return;
                case ResolveEnum.Shared:
                    serializer.Serialize(writer, "shared");
                    return;
            }
            throw new Exception("Cannot marshal type ResolveEnum");
        }

        public static readonly ResolveEnumConverter Singleton = new ResolveEnumConverter();
    }

    internal class ShapeUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ShapeUnion) || t == typeof(ShapeUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "arc":
                            return new ShapeUnion { Enum = ShapeEnum.Arc };
                        case "curve":
                            return new ShapeUnion { Enum = ShapeEnum.Curve };
                        case "diagonal":
                            return new ShapeUnion { Enum = ShapeEnum.Diagonal };
                        case "line":
                            return new ShapeUnion { Enum = ShapeEnum.Line };
                        case "orthogonal":
                            return new ShapeUnion { Enum = ShapeEnum.Orthogonal };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new ShapeUnion { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type ShapeUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ShapeUnion)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case ShapeEnum.Arc:
                        serializer.Serialize(writer, "arc");
                        return;
                    case ShapeEnum.Curve:
                        serializer.Serialize(writer, "curve");
                        return;
                    case ShapeEnum.Diagonal:
                        serializer.Serialize(writer, "diagonal");
                        return;
                    case ShapeEnum.Line:
                        serializer.Serialize(writer, "line");
                        return;
                    case ShapeEnum.Orthogonal:
                        serializer.Serialize(writer, "orthogonal");
                        return;
                }
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type ShapeUnion");
        }

        public static readonly ShapeUnionConverter Singleton = new ShapeUnionConverter();
    }

    internal class ShapeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ShapeEnum) || t == typeof(ShapeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "arc":
                    return ShapeEnum.Arc;
                case "curve":
                    return ShapeEnum.Curve;
                case "diagonal":
                    return ShapeEnum.Diagonal;
                case "line":
                    return ShapeEnum.Line;
                case "orthogonal":
                    return ShapeEnum.Orthogonal;
            }
            throw new Exception("Cannot unmarshal type ShapeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ShapeEnum)untypedValue;
            switch (value)
            {
                case ShapeEnum.Arc:
                    serializer.Serialize(writer, "arc");
                    return;
                case ShapeEnum.Curve:
                    serializer.Serialize(writer, "curve");
                    return;
                case ShapeEnum.Diagonal:
                    serializer.Serialize(writer, "diagonal");
                    return;
                case ShapeEnum.Line:
                    serializer.Serialize(writer, "line");
                    return;
                case ShapeEnum.Orthogonal:
                    serializer.Serialize(writer, "orthogonal");
                    return;
            }
            throw new Exception("Cannot marshal type ShapeEnum");
        }

        public static readonly ShapeEnumConverter Singleton = new ShapeEnumConverter();
    }

    internal class SortUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SortUnion) || t == typeof(SortUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new SortUnion { Bool = boolValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<CompareClass>(reader);
                    return new SortUnion { CompareClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type SortUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (SortUnion)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.CompareClass != null)
            {
                serializer.Serialize(writer, value.CompareClass);
                return;
            }
            throw new Exception("Cannot marshal type SortUnion");
        }

        public static readonly SortUnionConverter Singleton = new SortUnionConverter();
    }

    internal class CompareFieldConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CompareField) || t == typeof(CompareField?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new CompareField { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<IndigoSignalRef>(reader);
                    return new CompareField { IndigoSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<FieldField[]>(reader);
                    return new CompareField { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type CompareField");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (CompareField)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.IndigoSignalRef != null)
            {
                serializer.Serialize(writer, value.IndigoSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type CompareField");
        }

        public static readonly CompareFieldConverter Singleton = new CompareFieldConverter();
    }

    internal class FieldFieldConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FieldField) || t == typeof(FieldField?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new FieldField { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<IndigoSignalRef>(reader);
                    return new FieldField { IndigoSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type FieldField");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (FieldField)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.IndigoSignalRef != null)
            {
                serializer.Serialize(writer, value.IndigoSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type FieldField");
        }

        public static readonly FieldFieldConverter Singleton = new FieldFieldConverter();
    }

    internal class OrderUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OrderUnion) || t == typeof(OrderUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "ascending":
                            return new OrderUnion { Enum = OrderEnum.Ascending };
                        case "descending":
                            return new OrderUnion { Enum = OrderEnum.Descending };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new OrderUnion { FormatTypeSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<SortOrder[]>(reader);
                    return new OrderUnion { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type OrderUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (OrderUnion)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case OrderEnum.Ascending:
                        serializer.Serialize(writer, "ascending");
                        return;
                    case OrderEnum.Descending:
                        serializer.Serialize(writer, "descending");
                        return;
                }
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type OrderUnion");
        }

        public static readonly OrderUnionConverter Singleton = new OrderUnionConverter();
    }

    internal class SortOrderConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SortOrder) || t == typeof(SortOrder?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "ascending":
                            return new SortOrder { Enum = OrderEnum.Ascending };
                        case "descending":
                            return new SortOrder { Enum = OrderEnum.Descending };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new SortOrder { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type SortOrder");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (SortOrder)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case OrderEnum.Ascending:
                        serializer.Serialize(writer, "ascending");
                        return;
                    case OrderEnum.Descending:
                        serializer.Serialize(writer, "descending");
                        return;
                }
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type SortOrder");
        }

        public static readonly SortOrderConverter Singleton = new SortOrderConverter();
    }

    internal class OrderEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OrderEnum) || t == typeof(OrderEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ascending":
                    return OrderEnum.Ascending;
                case "descending":
                    return OrderEnum.Descending;
            }
            throw new Exception("Cannot unmarshal type OrderEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (OrderEnum)untypedValue;
            switch (value)
            {
                case OrderEnum.Ascending:
                    serializer.Serialize(writer, "ascending");
                    return;
                case OrderEnum.Descending:
                    serializer.Serialize(writer, "descending");
                    return;
            }
            throw new Exception("Cannot marshal type OrderEnum");
        }

        public static readonly OrderEnumConverter Singleton = new OrderEnumConverter();
    }

    internal class TimezoneUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TimezoneUnion) || t == typeof(TimezoneUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "local":
                            return new TimezoneUnion { Enum = TimezoneEnum.Local };
                        case "utc":
                            return new TimezoneUnion { Enum = TimezoneEnum.Utc };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new TimezoneUnion { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type TimezoneUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TimezoneUnion)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case TimezoneEnum.Local:
                        serializer.Serialize(writer, "local");
                        return;
                    case TimezoneEnum.Utc:
                        serializer.Serialize(writer, "utc");
                        return;
                }
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type TimezoneUnion");
        }

        public static readonly TimezoneUnionConverter Singleton = new TimezoneUnionConverter();
    }

    internal class TimezoneEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TimezoneEnum) || t == typeof(TimezoneEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "local":
                    return TimezoneEnum.Local;
                case "utc":
                    return TimezoneEnum.Utc;
            }
            throw new Exception("Cannot unmarshal type TimezoneEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TimezoneEnum)untypedValue;
            switch (value)
            {
                case TimezoneEnum.Local:
                    serializer.Serialize(writer, "local");
                    return;
                case TimezoneEnum.Utc:
                    serializer.Serialize(writer, "utc");
                    return;
            }
            throw new Exception("Cannot marshal type TimezoneEnum");
        }

        public static readonly TimezoneEnumConverter Singleton = new TimezoneEnumConverter();
    }

    internal class TranslateConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Translate) || t == typeof(Translate?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new Translate { FormatTypeSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<Radius[]>(reader);
                    return new Translate { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Translate");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Translate)untypedValue;
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type Translate");
        }

        public static readonly TranslateConverter Singleton = new TranslateConverter();
    }

    internal class TransformTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TransformType) || t == typeof(TransformType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "aggregate":
                    return TransformType.Aggregate;
                case "bin":
                    return TransformType.Bin;
                case "collect":
                    return TransformType.Collect;
                case "contour":
                    return TransformType.Contour;
                case "countpattern":
                    return TransformType.Countpattern;
                case "cross":
                    return TransformType.Cross;
                case "crossfilter":
                    return TransformType.Crossfilter;
                case "density":
                    return TransformType.Density;
                case "dotbin":
                    return TransformType.Dotbin;
                case "extent":
                    return TransformType.Extent;
                case "filter":
                    return TransformType.Filter;
                case "flatten":
                    return TransformType.Flatten;
                case "fold":
                    return TransformType.Fold;
                case "force":
                    return TransformType.Force;
                case "formula":
                    return TransformType.Formula;
                case "geojson":
                    return TransformType.Geojson;
                case "geopath":
                    return TransformType.Geopath;
                case "geopoint":
                    return TransformType.Geopoint;
                case "geoshape":
                    return TransformType.Geoshape;
                case "graticule":
                    return TransformType.Graticule;
                case "heatmap":
                    return TransformType.Heatmap;
                case "identifier":
                    return TransformType.Identifier;
                case "impute":
                    return TransformType.Impute;
                case "isocontour":
                    return TransformType.Isocontour;
                case "joinaggregate":
                    return TransformType.Joinaggregate;
                case "kde":
                    return TransformType.Kde;
                case "kde2d":
                    return TransformType.Kde2D;
                case "label":
                    return TransformType.Label;
                case "linkpath":
                    return TransformType.Linkpath;
                case "loess":
                    return TransformType.Loess;
                case "lookup":
                    return TransformType.Lookup;
                case "nest":
                    return TransformType.Nest;
                case "pack":
                    return TransformType.Pack;
                case "partition":
                    return TransformType.Partition;
                case "pie":
                    return TransformType.Pie;
                case "pivot":
                    return TransformType.Pivot;
                case "project":
                    return TransformType.Project;
                case "quantile":
                    return TransformType.Quantile;
                case "regression":
                    return TransformType.Regression;
                case "resolvefilter":
                    return TransformType.Resolvefilter;
                case "sample":
                    return TransformType.Sample;
                case "sequence":
                    return TransformType.Sequence;
                case "stack":
                    return TransformType.Stack;
                case "stratify":
                    return TransformType.Stratify;
                case "timeunit":
                    return TransformType.Timeunit;
                case "tree":
                    return TransformType.Tree;
                case "treelinks":
                    return TransformType.Treelinks;
                case "treemap":
                    return TransformType.Treemap;
                case "voronoi":
                    return TransformType.Voronoi;
                case "window":
                    return TransformType.Window;
                case "wordcloud":
                    return TransformType.Wordcloud;
            }
            throw new Exception("Cannot unmarshal type TransformType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TransformType)untypedValue;
            switch (value)
            {
                case TransformType.Aggregate:
                    serializer.Serialize(writer, "aggregate");
                    return;
                case TransformType.Bin:
                    serializer.Serialize(writer, "bin");
                    return;
                case TransformType.Collect:
                    serializer.Serialize(writer, "collect");
                    return;
                case TransformType.Contour:
                    serializer.Serialize(writer, "contour");
                    return;
                case TransformType.Countpattern:
                    serializer.Serialize(writer, "countpattern");
                    return;
                case TransformType.Cross:
                    serializer.Serialize(writer, "cross");
                    return;
                case TransformType.Crossfilter:
                    serializer.Serialize(writer, "crossfilter");
                    return;
                case TransformType.Density:
                    serializer.Serialize(writer, "density");
                    return;
                case TransformType.Dotbin:
                    serializer.Serialize(writer, "dotbin");
                    return;
                case TransformType.Extent:
                    serializer.Serialize(writer, "extent");
                    return;
                case TransformType.Filter:
                    serializer.Serialize(writer, "filter");
                    return;
                case TransformType.Flatten:
                    serializer.Serialize(writer, "flatten");
                    return;
                case TransformType.Fold:
                    serializer.Serialize(writer, "fold");
                    return;
                case TransformType.Force:
                    serializer.Serialize(writer, "force");
                    return;
                case TransformType.Formula:
                    serializer.Serialize(writer, "formula");
                    return;
                case TransformType.Geojson:
                    serializer.Serialize(writer, "geojson");
                    return;
                case TransformType.Geopath:
                    serializer.Serialize(writer, "geopath");
                    return;
                case TransformType.Geopoint:
                    serializer.Serialize(writer, "geopoint");
                    return;
                case TransformType.Geoshape:
                    serializer.Serialize(writer, "geoshape");
                    return;
                case TransformType.Graticule:
                    serializer.Serialize(writer, "graticule");
                    return;
                case TransformType.Heatmap:
                    serializer.Serialize(writer, "heatmap");
                    return;
                case TransformType.Identifier:
                    serializer.Serialize(writer, "identifier");
                    return;
                case TransformType.Impute:
                    serializer.Serialize(writer, "impute");
                    return;
                case TransformType.Isocontour:
                    serializer.Serialize(writer, "isocontour");
                    return;
                case TransformType.Joinaggregate:
                    serializer.Serialize(writer, "joinaggregate");
                    return;
                case TransformType.Kde:
                    serializer.Serialize(writer, "kde");
                    return;
                case TransformType.Kde2D:
                    serializer.Serialize(writer, "kde2d");
                    return;
                case TransformType.Label:
                    serializer.Serialize(writer, "label");
                    return;
                case TransformType.Linkpath:
                    serializer.Serialize(writer, "linkpath");
                    return;
                case TransformType.Loess:
                    serializer.Serialize(writer, "loess");
                    return;
                case TransformType.Lookup:
                    serializer.Serialize(writer, "lookup");
                    return;
                case TransformType.Nest:
                    serializer.Serialize(writer, "nest");
                    return;
                case TransformType.Pack:
                    serializer.Serialize(writer, "pack");
                    return;
                case TransformType.Partition:
                    serializer.Serialize(writer, "partition");
                    return;
                case TransformType.Pie:
                    serializer.Serialize(writer, "pie");
                    return;
                case TransformType.Pivot:
                    serializer.Serialize(writer, "pivot");
                    return;
                case TransformType.Project:
                    serializer.Serialize(writer, "project");
                    return;
                case TransformType.Quantile:
                    serializer.Serialize(writer, "quantile");
                    return;
                case TransformType.Regression:
                    serializer.Serialize(writer, "regression");
                    return;
                case TransformType.Resolvefilter:
                    serializer.Serialize(writer, "resolvefilter");
                    return;
                case TransformType.Sample:
                    serializer.Serialize(writer, "sample");
                    return;
                case TransformType.Sequence:
                    serializer.Serialize(writer, "sequence");
                    return;
                case TransformType.Stack:
                    serializer.Serialize(writer, "stack");
                    return;
                case TransformType.Stratify:
                    serializer.Serialize(writer, "stratify");
                    return;
                case TransformType.Timeunit:
                    serializer.Serialize(writer, "timeunit");
                    return;
                case TransformType.Tree:
                    serializer.Serialize(writer, "tree");
                    return;
                case TransformType.Treelinks:
                    serializer.Serialize(writer, "treelinks");
                    return;
                case TransformType.Treemap:
                    serializer.Serialize(writer, "treemap");
                    return;
                case TransformType.Voronoi:
                    serializer.Serialize(writer, "voronoi");
                    return;
                case TransformType.Window:
                    serializer.Serialize(writer, "window");
                    return;
                case TransformType.Wordcloud:
                    serializer.Serialize(writer, "wordcloud");
                    return;
            }
            throw new Exception("Cannot marshal type TransformType");
        }

        public static readonly TransformTypeConverter Singleton = new TransformTypeConverter();
    }

    internal class UnitsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Units) || t == typeof(Units?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new Units { FormatTypeSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<UnitElement[]>(reader);
                    return new Units { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Units");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Units)untypedValue;
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type Units");
        }

        public static readonly UnitsConverter Singleton = new UnitsConverter();
    }

    internal class UnitElementConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(UnitElement) || t == typeof(UnitElement?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "date":
                            return new UnitElement { Enum = UnitEnum.Date };
                        case "day":
                            return new UnitElement { Enum = UnitEnum.Day };
                        case "dayofyear":
                            return new UnitElement { Enum = UnitEnum.Dayofyear };
                        case "hours":
                            return new UnitElement { Enum = UnitEnum.Hours };
                        case "milliseconds":
                            return new UnitElement { Enum = UnitEnum.Milliseconds };
                        case "minutes":
                            return new UnitElement { Enum = UnitEnum.Minutes };
                        case "month":
                            return new UnitElement { Enum = UnitEnum.Month };
                        case "quarter":
                            return new UnitElement { Enum = UnitEnum.Quarter };
                        case "seconds":
                            return new UnitElement { Enum = UnitEnum.Seconds };
                        case "week":
                            return new UnitElement { Enum = UnitEnum.Week };
                        case "year":
                            return new UnitElement { Enum = UnitEnum.Year };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new UnitElement { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type UnitElement");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (UnitElement)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case UnitEnum.Date:
                        serializer.Serialize(writer, "date");
                        return;
                    case UnitEnum.Day:
                        serializer.Serialize(writer, "day");
                        return;
                    case UnitEnum.Dayofyear:
                        serializer.Serialize(writer, "dayofyear");
                        return;
                    case UnitEnum.Hours:
                        serializer.Serialize(writer, "hours");
                        return;
                    case UnitEnum.Milliseconds:
                        serializer.Serialize(writer, "milliseconds");
                        return;
                    case UnitEnum.Minutes:
                        serializer.Serialize(writer, "minutes");
                        return;
                    case UnitEnum.Month:
                        serializer.Serialize(writer, "month");
                        return;
                    case UnitEnum.Quarter:
                        serializer.Serialize(writer, "quarter");
                        return;
                    case UnitEnum.Seconds:
                        serializer.Serialize(writer, "seconds");
                        return;
                    case UnitEnum.Week:
                        serializer.Serialize(writer, "week");
                        return;
                    case UnitEnum.Year:
                        serializer.Serialize(writer, "year");
                        return;
                }
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type UnitElement");
        }

        public static readonly UnitElementConverter Singleton = new UnitElementConverter();
    }

    internal class UnitEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(UnitEnum) || t == typeof(UnitEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "date":
                    return UnitEnum.Date;
                case "day":
                    return UnitEnum.Day;
                case "dayofyear":
                    return UnitEnum.Dayofyear;
                case "hours":
                    return UnitEnum.Hours;
                case "milliseconds":
                    return UnitEnum.Milliseconds;
                case "minutes":
                    return UnitEnum.Minutes;
                case "month":
                    return UnitEnum.Month;
                case "quarter":
                    return UnitEnum.Quarter;
                case "seconds":
                    return UnitEnum.Seconds;
                case "week":
                    return UnitEnum.Week;
                case "year":
                    return UnitEnum.Year;
            }
            throw new Exception("Cannot unmarshal type UnitEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (UnitEnum)untypedValue;
            switch (value)
            {
                case UnitEnum.Date:
                    serializer.Serialize(writer, "date");
                    return;
                case UnitEnum.Day:
                    serializer.Serialize(writer, "day");
                    return;
                case UnitEnum.Dayofyear:
                    serializer.Serialize(writer, "dayofyear");
                    return;
                case UnitEnum.Hours:
                    serializer.Serialize(writer, "hours");
                    return;
                case UnitEnum.Milliseconds:
                    serializer.Serialize(writer, "milliseconds");
                    return;
                case UnitEnum.Minutes:
                    serializer.Serialize(writer, "minutes");
                    return;
                case UnitEnum.Month:
                    serializer.Serialize(writer, "month");
                    return;
                case UnitEnum.Quarter:
                    serializer.Serialize(writer, "quarter");
                    return;
                case UnitEnum.Seconds:
                    serializer.Serialize(writer, "seconds");
                    return;
                case UnitEnum.Week:
                    serializer.Serialize(writer, "week");
                    return;
                case UnitEnum.Year:
                    serializer.Serialize(writer, "year");
                    return;
            }
            throw new Exception("Cannot marshal type UnitEnum");
        }

        public static readonly UnitEnumConverter Singleton = new UnitEnumConverter();
    }

    internal class ValuesUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ValuesUnion) || t == typeof(ValuesUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new ValuesUnion { FormatTypeSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<ValueElement[]>(reader);
                    return new ValuesUnion { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type ValuesUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ValuesUnion)untypedValue;
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type ValuesUnion");
        }

        public static readonly ValuesUnionConverter Singleton = new ValuesUnionConverter();
    }

    internal class ValueElementConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ValueElement) || t == typeof(ValueElement?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new ValueElement { Double = doubleValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new ValueElement { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<IndecentSignalRef>(reader);
                    return new ValueElement { IndecentSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type ValueElement");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ValueElement)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.IndecentSignalRef != null)
            {
                serializer.Serialize(writer, value.IndecentSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type ValueElement");
        }

        public static readonly ValueElementConverter Singleton = new ValueElementConverter();
    }

    internal class AlignValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AlignValue) || t == typeof(AlignValue?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<LabelAlignClass>(reader);
                    return new AlignValue { LabelAlignClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<LabelAlignElement[]>(reader);
                    return new AlignValue { LabelAlignElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type AlignValue");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (AlignValue)untypedValue;
            if (value.LabelAlignElementArray != null)
            {
                serializer.Serialize(writer, value.LabelAlignElementArray);
                return;
            }
            if (value.LabelAlignClass != null)
            {
                serializer.Serialize(writer, value.LabelAlignClass);
                return;
            }
            throw new Exception("Cannot marshal type AlignValue");
        }

        public static readonly AlignValueConverter Singleton = new AlignValueConverter();
    }

    internal class BooleanValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BooleanValue) || t == typeof(BooleanValue?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<TickRoundClass>(reader);
                    return new BooleanValue { TickRoundClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<TickRoundElement[]>(reader);
                    return new BooleanValue { TickRoundElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type BooleanValue");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (BooleanValue)untypedValue;
            if (value.TickRoundElementArray != null)
            {
                serializer.Serialize(writer, value.TickRoundElementArray);
                return;
            }
            if (value.TickRoundClass != null)
            {
                serializer.Serialize(writer, value.TickRoundClass);
                return;
            }
            throw new Exception("Cannot marshal type BooleanValue");
        }

        public static readonly BooleanValueConverter Singleton = new BooleanValueConverter();
    }

    internal class StringValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(StringValue) || t == typeof(StringValue?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<DomainCapClass>(reader);
                    return new StringValue { DomainCapClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<DomainCapElement[]>(reader);
                    return new StringValue { DomainCapElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type StringValue");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (StringValue)untypedValue;
            if (value.DomainCapElementArray != null)
            {
                serializer.Serialize(writer, value.DomainCapElementArray);
                return;
            }
            if (value.DomainCapClass != null)
            {
                serializer.Serialize(writer, value.DomainCapClass);
                return;
            }
            throw new Exception("Cannot marshal type StringValue");
        }

        public static readonly StringValueConverter Singleton = new StringValueConverter();
    }

    internal class BaselineValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BaselineValue) || t == typeof(BaselineValue?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<LabelBaselineClass>(reader);
                    return new BaselineValue { LabelBaselineClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<LabelBaselineElement[]>(reader);
                    return new BaselineValue { LabelBaselineElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type BaselineValue");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (BaselineValue)untypedValue;
            if (value.LabelBaselineElementArray != null)
            {
                serializer.Serialize(writer, value.LabelBaselineElementArray);
                return;
            }
            if (value.LabelBaselineClass != null)
            {
                serializer.Serialize(writer, value.LabelBaselineClass);
                return;
            }
            throw new Exception("Cannot marshal type BaselineValue");
        }

        public static readonly BaselineValueConverter Singleton = new BaselineValueConverter();
    }

    internal class BlendValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BlendValue) || t == typeof(BlendValue?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<BlendValueClass>(reader);
                    return new BlendValue { BlendValueClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<BlendValueElement[]>(reader);
                    return new BlendValue { BlendValueElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type BlendValue");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (BlendValue)untypedValue;
            if (value.BlendValueElementArray != null)
            {
                serializer.Serialize(writer, value.BlendValueElementArray);
                return;
            }
            if (value.BlendValueClass != null)
            {
                serializer.Serialize(writer, value.BlendValueClass);
                return;
            }
            throw new Exception("Cannot marshal type BlendValue");
        }

        public static readonly BlendValueConverter Singleton = new BlendValueConverter();
    }

    internal class ColorValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ColorValue) || t == typeof(ColorValue?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FluffyBaseColorValue>(reader);
                    return new ColorValue { FluffyBaseColorValue = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<BaseColorValue[]>(reader);
                    return new ColorValue { BaseColorValueArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type ColorValue");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ColorValue)untypedValue;
            if (value.BaseColorValueArray != null)
            {
                serializer.Serialize(writer, value.BaseColorValueArray);
                return;
            }
            if (value.FluffyBaseColorValue != null)
            {
                serializer.Serialize(writer, value.FluffyBaseColorValue);
                return;
            }
            throw new Exception("Cannot marshal type ColorValue");
        }

        public static readonly ColorValueConverter Singleton = new ColorValueConverter();
    }

    internal class FontWeightValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FontWeightValue) || t == typeof(FontWeightValue?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<LabelFontWeightClass>(reader);
                    return new FontWeightValue { LabelFontWeightClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<LabelFontWeightElement[]>(reader);
                    return new FontWeightValue { LabelFontWeightElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type FontWeightValue");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (FontWeightValue)untypedValue;
            if (value.LabelFontWeightElementArray != null)
            {
                serializer.Serialize(writer, value.LabelFontWeightElementArray);
                return;
            }
            if (value.LabelFontWeightClass != null)
            {
                serializer.Serialize(writer, value.LabelFontWeightClass);
                return;
            }
            throw new Exception("Cannot marshal type FontWeightValue");
        }

        public static readonly FontWeightValueConverter Singleton = new FontWeightValueConverter();
    }

    internal class DirectionValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DirectionValue) || t == typeof(DirectionValue?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<DirectionValueClass>(reader);
                    return new DirectionValue { DirectionValueClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<DirectionValueElement[]>(reader);
                    return new DirectionValue { DirectionValueElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type DirectionValue");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (DirectionValue)untypedValue;
            if (value.DirectionValueElementArray != null)
            {
                serializer.Serialize(writer, value.DirectionValueElementArray);
                return;
            }
            if (value.DirectionValueClass != null)
            {
                serializer.Serialize(writer, value.DirectionValueClass);
                return;
            }
            throw new Exception("Cannot marshal type DirectionValue");
        }

        public static readonly DirectionValueConverter Singleton = new DirectionValueConverter();
    }

    internal class StrokeCapValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(StrokeCapValue) || t == typeof(StrokeCapValue?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<StrokeCapValueClass>(reader);
                    return new StrokeCapValue { StrokeCapValueClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<StrokeCapValueElement[]>(reader);
                    return new StrokeCapValue { StrokeCapValueElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type StrokeCapValue");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (StrokeCapValue)untypedValue;
            if (value.StrokeCapValueElementArray != null)
            {
                serializer.Serialize(writer, value.StrokeCapValueElementArray);
                return;
            }
            if (value.StrokeCapValueClass != null)
            {
                serializer.Serialize(writer, value.StrokeCapValueClass);
                return;
            }
            throw new Exception("Cannot marshal type StrokeCapValue");
        }

        public static readonly StrokeCapValueConverter Singleton = new StrokeCapValueConverter();
    }

    internal class ArrayValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ArrayValue) || t == typeof(ArrayValue?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<DomainDashClass>(reader);
                    return new ArrayValue { DomainDashClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<ArrayValueElement[]>(reader);
                    return new ArrayValue { ArrayValueElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type ArrayValue");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ArrayValue)untypedValue;
            if (value.ArrayValueElementArray != null)
            {
                serializer.Serialize(writer, value.ArrayValueElementArray);
                return;
            }
            if (value.DomainDashClass != null)
            {
                serializer.Serialize(writer, value.DomainDashClass);
                return;
            }
            throw new Exception("Cannot marshal type ArrayValue");
        }

        public static readonly ArrayValueConverter Singleton = new ArrayValueConverter();
    }

    internal class StrokeJoinValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(StrokeJoinValue) || t == typeof(StrokeJoinValue?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<StrokeJoinValueClass>(reader);
                    return new StrokeJoinValue { StrokeJoinValueClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<StrokeJoinValueElement[]>(reader);
                    return new StrokeJoinValue { StrokeJoinValueElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type StrokeJoinValue");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (StrokeJoinValue)untypedValue;
            if (value.StrokeJoinValueElementArray != null)
            {
                serializer.Serialize(writer, value.StrokeJoinValueElementArray);
                return;
            }
            if (value.StrokeJoinValueClass != null)
            {
                serializer.Serialize(writer, value.StrokeJoinValueClass);
                return;
            }
            throw new Exception("Cannot marshal type StrokeJoinValue");
        }

        public static readonly StrokeJoinValueConverter Singleton = new StrokeJoinValueConverter();
    }

    internal class TextValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TextValue) || t == typeof(TextValue?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<TextValueClass>(reader);
                    return new TextValue { TextValueClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<TextValueElement[]>(reader);
                    return new TextValue { TextValueElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type TextValue");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TextValue)untypedValue;
            if (value.TextValueElementArray != null)
            {
                serializer.Serialize(writer, value.TextValueElementArray);
                return;
            }
            if (value.TextValueClass != null)
            {
                serializer.Serialize(writer, value.TextValueClass);
                return;
            }
            throw new Exception("Cannot marshal type TextValue");
        }

        public static readonly TextValueConverter Singleton = new TextValueConverter();
    }

    internal class AnyValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AnyValue) || t == typeof(AnyValue?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<AnyValueClass>(reader);
                    return new AnyValue { AnyValueClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<AnyValueElement[]>(reader);
                    return new AnyValue { AnyValueElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type AnyValue");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (AnyValue)untypedValue;
            if (value.AnyValueElementArray != null)
            {
                serializer.Serialize(writer, value.AnyValueElementArray);
                return;
            }
            if (value.AnyValueClass != null)
            {
                serializer.Serialize(writer, value.AnyValueClass);
                return;
            }
            throw new Exception("Cannot marshal type AnyValue");
        }

        public static readonly AnyValueConverter Singleton = new AnyValueConverter();
    }

    internal class AlignUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AlignUnion) || t == typeof(AlignUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "all":
                            return new AlignUnion { Enum = AlignEnum.All };
                        case "each":
                            return new AlignUnion { Enum = AlignEnum.Each };
                        case "none":
                            return new AlignUnion { Enum = AlignEnum.None };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<HilariousSignalRef>(reader);
                    return new AlignUnion { HilariousSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type AlignUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (AlignUnion)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case AlignEnum.All:
                        serializer.Serialize(writer, "all");
                        return;
                    case AlignEnum.Each:
                        serializer.Serialize(writer, "each");
                        return;
                    case AlignEnum.None:
                        serializer.Serialize(writer, "none");
                        return;
                }
            }
            if (value.HilariousSignalRef != null)
            {
                serializer.Serialize(writer, value.HilariousSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type AlignUnion");
        }

        public static readonly AlignUnionConverter Singleton = new AlignUnionConverter();
    }

    internal class GridAlignUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(GridAlignUnion) || t == typeof(GridAlignUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "all":
                            return new GridAlignUnion { Enum = AlignEnum.All };
                        case "each":
                            return new GridAlignUnion { Enum = AlignEnum.Each };
                        case "none":
                            return new GridAlignUnion { Enum = AlignEnum.None };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new GridAlignUnion { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type GridAlignUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (GridAlignUnion)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case AlignEnum.All:
                        serializer.Serialize(writer, "all");
                        return;
                    case AlignEnum.Each:
                        serializer.Serialize(writer, "each");
                        return;
                    case AlignEnum.None:
                        serializer.Serialize(writer, "none");
                        return;
                }
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type GridAlignUnion");
        }

        public static readonly GridAlignUnionConverter Singleton = new GridAlignUnionConverter();
    }

    internal class AlignEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AlignEnum) || t == typeof(AlignEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "all":
                    return AlignEnum.All;
                case "each":
                    return AlignEnum.Each;
                case "none":
                    return AlignEnum.None;
            }
            throw new Exception("Cannot unmarshal type AlignEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AlignEnum)untypedValue;
            switch (value)
            {
                case AlignEnum.All:
                    serializer.Serialize(writer, "all");
                    return;
                case AlignEnum.Each:
                    serializer.Serialize(writer, "each");
                    return;
                case AlignEnum.None:
                    serializer.Serialize(writer, "none");
                    return;
            }
            throw new Exception("Cannot marshal type AlignEnum");
        }

        public static readonly AlignEnumConverter Singleton = new AlignEnumConverter();
    }

    internal class BoundsUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BoundsUnion) || t == typeof(BoundsUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "flush":
                            return new BoundsUnion { Enum = BoundsEnum.Flush };
                        case "full":
                            return new BoundsUnion { Enum = BoundsEnum.Full };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new BoundsUnion { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type BoundsUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (BoundsUnion)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case BoundsEnum.Flush:
                        serializer.Serialize(writer, "flush");
                        return;
                    case BoundsEnum.Full:
                        serializer.Serialize(writer, "full");
                        return;
                }
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type BoundsUnion");
        }

        public static readonly BoundsUnionConverter Singleton = new BoundsUnionConverter();
    }

    internal class BoundsEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BoundsEnum) || t == typeof(BoundsEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "flush":
                    return BoundsEnum.Flush;
                case "full":
                    return BoundsEnum.Full;
            }
            throw new Exception("Cannot unmarshal type BoundsEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (BoundsEnum)untypedValue;
            switch (value)
            {
                case BoundsEnum.Flush:
                    serializer.Serialize(writer, "flush");
                    return;
                case BoundsEnum.Full:
                    serializer.Serialize(writer, "full");
                    return;
            }
            throw new Exception("Cannot marshal type BoundsEnum");
        }

        public static readonly BoundsEnumConverter Singleton = new BoundsEnumConverter();
    }

    internal class CenterConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Center) || t == typeof(Center?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new Center { Bool = boolValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<AmbitiousSignalRef>(reader);
                    return new Center { AmbitiousSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type Center");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Center)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.AmbitiousSignalRef != null)
            {
                serializer.Serialize(writer, value.AmbitiousSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type Center");
        }

        public static readonly CenterConverter Singleton = new CenterConverter();
    }

    internal class FooterBandUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FooterBandUnion) || t == typeof(FooterBandUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new FooterBandUnion { };
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new FooterBandUnion { Double = doubleValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FooterBandSignalRef>(reader);
                    return new FooterBandUnion { FooterBandSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type FooterBandUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (FooterBandUnion)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.FooterBandSignalRef != null)
            {
                serializer.Serialize(writer, value.FooterBandSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type FooterBandUnion");
        }

        public static readonly FooterBandUnionConverter Singleton = new FooterBandUnionConverter();
    }

    internal class HeaderBandUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(HeaderBandUnion) || t == typeof(HeaderBandUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new HeaderBandUnion { };
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new HeaderBandUnion { Double = doubleValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<HeaderBandSignalRef>(reader);
                    return new HeaderBandUnion { HeaderBandSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type HeaderBandUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (HeaderBandUnion)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.HeaderBandSignalRef != null)
            {
                serializer.Serialize(writer, value.HeaderBandSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type HeaderBandUnion");
        }

        public static readonly HeaderBandUnionConverter Singleton = new HeaderBandUnionConverter();
    }

    internal class LayoutOffsetConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LayoutOffset) || t == typeof(LayoutOffset?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new LayoutOffset { Double = doubleValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<CunningSignalRef>(reader);
                    return new LayoutOffset { CunningSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type LayoutOffset");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (LayoutOffset)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.CunningSignalRef != null)
            {
                serializer.Serialize(writer, value.CunningSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type LayoutOffset");
        }

        public static readonly LayoutOffsetConverter Singleton = new LayoutOffsetConverter();
    }

    internal class PaddingUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PaddingUnion) || t == typeof(PaddingUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new PaddingUnion { Double = doubleValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<MagentaSignalRef>(reader);
                    return new PaddingUnion { MagentaSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type PaddingUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (PaddingUnion)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.MagentaSignalRef != null)
            {
                serializer.Serialize(writer, value.MagentaSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type PaddingUnion");
        }

        public static readonly PaddingUnionConverter Singleton = new PaddingUnionConverter();
    }

    internal class TitleAnchorConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TitleAnchor) || t == typeof(TitleAnchor?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "end":
                            return new TitleAnchor { Enum = TitleAnchorEnum.End };
                        case "start":
                            return new TitleAnchor { Enum = TitleAnchorEnum.Start };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<TitleAnchorSignalRef>(reader);
                    return new TitleAnchor { TitleAnchorSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type TitleAnchor");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TitleAnchor)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case TitleAnchorEnum.End:
                        serializer.Serialize(writer, "end");
                        return;
                    case TitleAnchorEnum.Start:
                        serializer.Serialize(writer, "start");
                        return;
                }
            }
            if (value.TitleAnchorSignalRef != null)
            {
                serializer.Serialize(writer, value.TitleAnchorSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type TitleAnchor");
        }

        public static readonly TitleAnchorConverter Singleton = new TitleAnchorConverter();
    }

    internal class PurpleColumnConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PurpleColumn) || t == typeof(PurpleColumn?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "end":
                            return new PurpleColumn { Enum = TitleAnchorEnum.End };
                        case "start":
                            return new PurpleColumn { Enum = TitleAnchorEnum.Start };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new PurpleColumn { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type PurpleColumn");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (PurpleColumn)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case TitleAnchorEnum.End:
                        serializer.Serialize(writer, "end");
                        return;
                    case TitleAnchorEnum.Start:
                        serializer.Serialize(writer, "start");
                        return;
                }
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type PurpleColumn");
        }

        public static readonly PurpleColumnConverter Singleton = new PurpleColumnConverter();
    }

    internal class TitleAnchorEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TitleAnchorEnum) || t == typeof(TitleAnchorEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "end":
                    return TitleAnchorEnum.End;
                case "start":
                    return TitleAnchorEnum.Start;
            }
            throw new Exception("Cannot unmarshal type TitleAnchorEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TitleAnchorEnum)untypedValue;
            switch (value)
            {
                case TitleAnchorEnum.End:
                    serializer.Serialize(writer, "end");
                    return;
                case TitleAnchorEnum.Start:
                    serializer.Serialize(writer, "start");
                    return;
            }
            throw new Exception("Cannot marshal type TitleAnchorEnum");
        }

        public static readonly TitleAnchorEnumConverter Singleton = new TitleAnchorEnumConverter();
    }

    internal class TitleBandUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TitleBandUnion) || t == typeof(TitleBandUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new TitleBandUnion { };
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new TitleBandUnion { Double = doubleValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<TitleBandSignalRef>(reader);
                    return new TitleBandUnion { TitleBandSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type TitleBandUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TitleBandUnion)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.TitleBandSignalRef != null)
            {
                serializer.Serialize(writer, value.TitleBandSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type TitleBandUnion");
        }

        public static readonly TitleBandUnionConverter Singleton = new TitleBandUnionConverter();
    }

    internal class DirectionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Direction) || t == typeof(Direction?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "horizontal":
                    return Direction.Horizontal;
                case "vertical":
                    return Direction.Vertical;
            }
            throw new Exception("Cannot unmarshal type Direction");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Direction)untypedValue;
            switch (value)
            {
                case Direction.Horizontal:
                    serializer.Serialize(writer, "horizontal");
                    return;
                case Direction.Vertical:
                    serializer.Serialize(writer, "vertical");
                    return;
            }
            throw new Exception("Cannot marshal type Direction");
        }

        public static readonly DirectionConverter Singleton = new DirectionConverter();
    }

    internal class LegendFormatConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LegendFormat) || t == typeof(LegendFormat?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new LegendFormat { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FriskySignalRef>(reader);
                    return new LegendFormat { FriskySignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type LegendFormat");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (LegendFormat)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.FriskySignalRef != null)
            {
                serializer.Serialize(writer, value.FriskySignalRef);
                return;
            }
            throw new Exception("Cannot marshal type LegendFormat");
        }

        public static readonly LegendFormatConverter Singleton = new LegendFormatConverter();
    }

    internal class LegendOrientConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LegendOrient) || t == typeof(LegendOrient?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "bottom":
                            return new LegendOrient { Enum = FluffyOrient.Bottom };
                        case "bottom-left":
                            return new LegendOrient { Enum = FluffyOrient.BottomLeft };
                        case "bottom-right":
                            return new LegendOrient { Enum = FluffyOrient.BottomRight };
                        case "left":
                            return new LegendOrient { Enum = FluffyOrient.Left };
                        case "none":
                            return new LegendOrient { Enum = FluffyOrient.None };
                        case "right":
                            return new LegendOrient { Enum = FluffyOrient.Right };
                        case "top":
                            return new LegendOrient { Enum = FluffyOrient.Top };
                        case "top-left":
                            return new LegendOrient { Enum = FluffyOrient.TopLeft };
                        case "top-right":
                            return new LegendOrient { Enum = FluffyOrient.TopRight };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new LegendOrient { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type LegendOrient");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (LegendOrient)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case FluffyOrient.Bottom:
                        serializer.Serialize(writer, "bottom");
                        return;
                    case FluffyOrient.BottomLeft:
                        serializer.Serialize(writer, "bottom-left");
                        return;
                    case FluffyOrient.BottomRight:
                        serializer.Serialize(writer, "bottom-right");
                        return;
                    case FluffyOrient.Left:
                        serializer.Serialize(writer, "left");
                        return;
                    case FluffyOrient.None:
                        serializer.Serialize(writer, "none");
                        return;
                    case FluffyOrient.Right:
                        serializer.Serialize(writer, "right");
                        return;
                    case FluffyOrient.Top:
                        serializer.Serialize(writer, "top");
                        return;
                    case FluffyOrient.TopLeft:
                        serializer.Serialize(writer, "top-left");
                        return;
                    case FluffyOrient.TopRight:
                        serializer.Serialize(writer, "top-right");
                        return;
                }
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type LegendOrient");
        }

        public static readonly LegendOrientConverter Singleton = new LegendOrientConverter();
    }

    internal class FluffyOrientConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FluffyOrient) || t == typeof(FluffyOrient?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "bottom":
                    return FluffyOrient.Bottom;
                case "bottom-left":
                    return FluffyOrient.BottomLeft;
                case "bottom-right":
                    return FluffyOrient.BottomRight;
                case "left":
                    return FluffyOrient.Left;
                case "none":
                    return FluffyOrient.None;
                case "right":
                    return FluffyOrient.Right;
                case "top":
                    return FluffyOrient.Top;
                case "top-left":
                    return FluffyOrient.TopLeft;
                case "top-right":
                    return FluffyOrient.TopRight;
            }
            throw new Exception("Cannot unmarshal type FluffyOrient");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FluffyOrient)untypedValue;
            switch (value)
            {
                case FluffyOrient.Bottom:
                    serializer.Serialize(writer, "bottom");
                    return;
                case FluffyOrient.BottomLeft:
                    serializer.Serialize(writer, "bottom-left");
                    return;
                case FluffyOrient.BottomRight:
                    serializer.Serialize(writer, "bottom-right");
                    return;
                case FluffyOrient.Left:
                    serializer.Serialize(writer, "left");
                    return;
                case FluffyOrient.None:
                    serializer.Serialize(writer, "none");
                    return;
                case FluffyOrient.Right:
                    serializer.Serialize(writer, "right");
                    return;
                case FluffyOrient.Top:
                    serializer.Serialize(writer, "top");
                    return;
                case FluffyOrient.TopLeft:
                    serializer.Serialize(writer, "top-left");
                    return;
                case FluffyOrient.TopRight:
                    serializer.Serialize(writer, "top-right");
                    return;
            }
            throw new Exception("Cannot marshal type FluffyOrient");
        }

        public static readonly FluffyOrientConverter Singleton = new FluffyOrientConverter();
    }

    internal class TitleOrientUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TitleOrientUnion) || t == typeof(TitleOrientUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "bottom":
                            return new TitleOrientUnion { Enum = TitleOrientEnum.Bottom };
                        case "left":
                            return new TitleOrientUnion { Enum = TitleOrientEnum.Left };
                        case "right":
                            return new TitleOrientUnion { Enum = TitleOrientEnum.Right };
                        case "top":
                            return new TitleOrientUnion { Enum = TitleOrientEnum.Top };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<OrientValue>(reader);
                    return new TitleOrientUnion { OrientValue = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<TitleOrientElement[]>(reader);
                    return new TitleOrientUnion { TitleOrientElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type TitleOrientUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TitleOrientUnion)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case TitleOrientEnum.Bottom:
                        serializer.Serialize(writer, "bottom");
                        return;
                    case TitleOrientEnum.Left:
                        serializer.Serialize(writer, "left");
                        return;
                    case TitleOrientEnum.Right:
                        serializer.Serialize(writer, "right");
                        return;
                    case TitleOrientEnum.Top:
                        serializer.Serialize(writer, "top");
                        return;
                }
            }
            if (value.TitleOrientElementArray != null)
            {
                serializer.Serialize(writer, value.TitleOrientElementArray);
                return;
            }
            if (value.OrientValue != null)
            {
                serializer.Serialize(writer, value.OrientValue);
                return;
            }
            throw new Exception("Cannot marshal type TitleOrientUnion");
        }

        public static readonly TitleOrientUnionConverter Singleton = new TitleOrientUnionConverter();
    }

    internal class LegendTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LegendType) || t == typeof(LegendType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "gradient":
                    return LegendType.Gradient;
                case "symbol":
                    return LegendType.Symbol;
            }
            throw new Exception("Cannot unmarshal type LegendType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (LegendType)untypedValue;
            switch (value)
            {
                case LegendType.Gradient:
                    serializer.Serialize(writer, "gradient");
                    return;
                case LegendType.Symbol:
                    serializer.Serialize(writer, "symbol");
                    return;
            }
            throw new Exception("Cannot marshal type LegendType");
        }

        public static readonly LegendTypeConverter Singleton = new LegendTypeConverter();
    }

    internal class MarkclipConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Markclip) || t == typeof(Markclip?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new Markclip { Bool = boolValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<MarkclipSignalRef>(reader);
                    return new Markclip { MarkclipSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type Markclip");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Markclip)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.MarkclipSignalRef != null)
            {
                serializer.Serialize(writer, value.MarkclipSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type Markclip");
        }

        public static readonly MarkclipConverter Singleton = new MarkclipConverter();
    }

    internal class ExtentConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Extent) || t == typeof(Extent?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new Extent { FormatTypeSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<CenterElement[]>(reader);
                    return new Extent { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Extent");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Extent)untypedValue;
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type Extent");
        }

        public static readonly ExtentConverter Singleton = new ExtentConverter();
    }

    internal class FitConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Fit) || t == typeof(Fit?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<Dictionary<string, object>>(reader);
                    return new Fit { AnythingMap = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<object[]>(reader);
                    return new Fit { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Fit");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Fit)untypedValue;
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.AnythingMap != null)
            {
                serializer.Serialize(writer, value.AnythingMap);
                return;
            }
            throw new Exception("Cannot marshal type Fit");
        }

        public static readonly FitConverter Singleton = new FitConverter();
    }

    internal class ScaleBinsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ScaleBins) || t == typeof(ScaleBins?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<ScaleBinsSignalRef>(reader);
                    return new ScaleBins { ScaleBinsSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<HeightElement[]>(reader);
                    return new ScaleBins { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type ScaleBins");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ScaleBins)untypedValue;
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.ScaleBinsSignalRef != null)
            {
                serializer.Serialize(writer, value.ScaleBinsSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type ScaleBins");
        }

        public static readonly ScaleBinsConverter Singleton = new ScaleBinsConverter();
    }

    internal class ScaleDataConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ScaleData) || t == typeof(ScaleData?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<MischievousSignalRef>(reader);
                    return new ScaleData { MischievousSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<Domain[]>(reader);
                    return new ScaleData { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type ScaleData");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ScaleData)untypedValue;
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.MischievousSignalRef != null)
            {
                serializer.Serialize(writer, value.MischievousSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type ScaleData");
        }

        public static readonly ScaleDataConverter Singleton = new ScaleDataConverter();
    }

    internal class DomainConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Domain) || t == typeof(Domain?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new Domain { };
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Domain { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new Domain { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Domain { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new Domain { FormatTypeSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<HeightElement[]>(reader);
                    return new Domain { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Domain");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Domain)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type Domain");
        }

        public static readonly DomainConverter Singleton = new DomainConverter();
    }

    internal class PurpleStringOrSignalConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PurpleStringOrSignal) || t == typeof(PurpleStringOrSignal?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new PurpleStringOrSignal { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<BraggadociousSignalRef>(reader);
                    return new PurpleStringOrSignal { BraggadociousSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<FieldElement[]>(reader);
                    return new PurpleStringOrSignal { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type PurpleStringOrSignal");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (PurpleStringOrSignal)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.BraggadociousSignalRef != null)
            {
                serializer.Serialize(writer, value.BraggadociousSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type PurpleStringOrSignal");
        }

        public static readonly PurpleStringOrSignalConverter Singleton = new PurpleStringOrSignalConverter();
    }

    internal class FieldElementConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FieldElement) || t == typeof(FieldElement?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new FieldElement { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new FieldElement { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new FieldElement { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type FieldElement");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (FieldElement)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type FieldElement");
        }

        public static readonly FieldElementConverter Singleton = new FieldElementConverter();
    }

    internal class TentacledSortConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TentacledSort) || t == typeof(TentacledSort?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new TentacledSort { Bool = boolValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<PurpleSort>(reader);
                    return new TentacledSort { PurpleSort = objectValue };
            }
            throw new Exception("Cannot unmarshal type TentacledSort");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TentacledSort)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.PurpleSort != null)
            {
                serializer.Serialize(writer, value.PurpleSort);
                return;
            }
            throw new Exception("Cannot marshal type TentacledSort");
        }

        public static readonly TentacledSortConverter Singleton = new TentacledSortConverter();
    }

    internal class DomainRawConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DomainRaw) || t == typeof(DomainRaw?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new DomainRaw { };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new DomainRaw { FormatTypeSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<object[]>(reader);
                    return new DomainRaw { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type DomainRaw");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (DomainRaw)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type DomainRaw");
        }

        public static readonly DomainRawConverter Singleton = new DomainRawConverter();
    }

    internal class ScaleInterpolateConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ScaleInterpolate) || t == typeof(ScaleInterpolate?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new ScaleInterpolate { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<ScaleInterpolateSignalRef>(reader);
                    return new ScaleInterpolate { ScaleInterpolateSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type ScaleInterpolate");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ScaleInterpolate)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.ScaleInterpolateSignalRef != null)
            {
                serializer.Serialize(writer, value.ScaleInterpolateSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type ScaleInterpolate");
        }

        public static readonly ScaleInterpolateConverter Singleton = new ScaleInterpolateConverter();
    }

    internal class PurpleBooleanOrSignalConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PurpleBooleanOrSignal) || t == typeof(PurpleBooleanOrSignal?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new PurpleBooleanOrSignal { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new PurpleBooleanOrSignal { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "day":
                            return new PurpleBooleanOrSignal { Enum = TickCountEnum.Day };
                        case "hour":
                            return new PurpleBooleanOrSignal { Enum = TickCountEnum.Hour };
                        case "millisecond":
                            return new PurpleBooleanOrSignal { Enum = TickCountEnum.Millisecond };
                        case "minute":
                            return new PurpleBooleanOrSignal { Enum = TickCountEnum.Minute };
                        case "month":
                            return new PurpleBooleanOrSignal { Enum = TickCountEnum.Month };
                        case "second":
                            return new PurpleBooleanOrSignal { Enum = TickCountEnum.Second };
                        case "week":
                            return new PurpleBooleanOrSignal { Enum = TickCountEnum.Week };
                        case "year":
                            return new PurpleBooleanOrSignal { Enum = TickCountEnum.Year };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<SignalRef1>(reader);
                    return new PurpleBooleanOrSignal { SignalRef1 = objectValue };
            }
            throw new Exception("Cannot unmarshal type PurpleBooleanOrSignal");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (PurpleBooleanOrSignal)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case TickCountEnum.Day:
                        serializer.Serialize(writer, "day");
                        return;
                    case TickCountEnum.Hour:
                        serializer.Serialize(writer, "hour");
                        return;
                    case TickCountEnum.Millisecond:
                        serializer.Serialize(writer, "millisecond");
                        return;
                    case TickCountEnum.Minute:
                        serializer.Serialize(writer, "minute");
                        return;
                    case TickCountEnum.Month:
                        serializer.Serialize(writer, "month");
                        return;
                    case TickCountEnum.Second:
                        serializer.Serialize(writer, "second");
                        return;
                    case TickCountEnum.Week:
                        serializer.Serialize(writer, "week");
                        return;
                    case TickCountEnum.Year:
                        serializer.Serialize(writer, "year");
                        return;
                }
            }
            if (value.SignalRef1 != null)
            {
                serializer.Serialize(writer, value.SignalRef1);
                return;
            }
            throw new Exception("Cannot marshal type PurpleBooleanOrSignal");
        }

        public static readonly PurpleBooleanOrSignalConverter Singleton = new PurpleBooleanOrSignalConverter();
    }

    internal class RangeUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(RangeUnion) || t == typeof(RangeUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "category":
                            return new RangeUnion { Enum = RangeEnum.Category };
                        case "diverging":
                            return new RangeUnion { Enum = RangeEnum.Diverging };
                        case "heatmap":
                            return new RangeUnion { Enum = RangeEnum.Heatmap };
                        case "height":
                            return new RangeUnion { Enum = RangeEnum.Height };
                        case "ordinal":
                            return new RangeUnion { Enum = RangeEnum.Ordinal };
                        case "ramp":
                            return new RangeUnion { Enum = RangeEnum.Ramp };
                        case "symbol":
                            return new RangeUnion { Enum = RangeEnum.Symbol };
                        case "width":
                            return new RangeUnion { Enum = RangeEnum.Width };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<SignalRef2>(reader);
                    return new RangeUnion { SignalRef2 = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<Domain[]>(reader);
                    return new RangeUnion { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type RangeUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (RangeUnion)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case RangeEnum.Category:
                        serializer.Serialize(writer, "category");
                        return;
                    case RangeEnum.Diverging:
                        serializer.Serialize(writer, "diverging");
                        return;
                    case RangeEnum.Heatmap:
                        serializer.Serialize(writer, "heatmap");
                        return;
                    case RangeEnum.Height:
                        serializer.Serialize(writer, "height");
                        return;
                    case RangeEnum.Ordinal:
                        serializer.Serialize(writer, "ordinal");
                        return;
                    case RangeEnum.Ramp:
                        serializer.Serialize(writer, "ramp");
                        return;
                    case RangeEnum.Symbol:
                        serializer.Serialize(writer, "symbol");
                        return;
                    case RangeEnum.Width:
                        serializer.Serialize(writer, "width");
                        return;
                }
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.SignalRef2 != null)
            {
                serializer.Serialize(writer, value.SignalRef2);
                return;
            }
            throw new Exception("Cannot marshal type RangeUnion");
        }

        public static readonly RangeUnionConverter Singleton = new RangeUnionConverter();
    }

    internal class FluffyStringOrSignalConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FluffyStringOrSignal) || t == typeof(FluffyStringOrSignal?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new FluffyStringOrSignal { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<SignalRef3>(reader);
                    return new FluffyStringOrSignal { SignalRef3 = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<FieldElement[]>(reader);
                    return new FluffyStringOrSignal { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type FluffyStringOrSignal");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (FluffyStringOrSignal)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.SignalRef3 != null)
            {
                serializer.Serialize(writer, value.SignalRef3);
                return;
            }
            throw new Exception("Cannot marshal type FluffyStringOrSignal");
        }

        public static readonly FluffyStringOrSignalConverter Singleton = new FluffyStringOrSignalConverter();
    }

    internal class SchemeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Scheme) || t == typeof(Scheme?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Scheme { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new Scheme { FormatTypeSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<BackgroundElement[]>(reader);
                    return new Scheme { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Scheme");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Scheme)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type Scheme");
        }

        public static readonly SchemeConverter Singleton = new SchemeConverter();
    }

    internal class StickySortConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(StickySort) || t == typeof(StickySort?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new StickySort { Bool = boolValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FluffySort>(reader);
                    return new StickySort { FluffySort = objectValue };
            }
            throw new Exception("Cannot unmarshal type StickySort");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (StickySort)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.FluffySort != null)
            {
                serializer.Serialize(writer, value.FluffySort);
                return;
            }
            throw new Exception("Cannot marshal type StickySort");
        }

        public static readonly StickySortConverter Singleton = new StickySortConverter();
    }

    internal class RangeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(RangeEnum) || t == typeof(RangeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "category":
                    return RangeEnum.Category;
                case "diverging":
                    return RangeEnum.Diverging;
                case "heatmap":
                    return RangeEnum.Heatmap;
                case "height":
                    return RangeEnum.Height;
                case "ordinal":
                    return RangeEnum.Ordinal;
                case "ramp":
                    return RangeEnum.Ramp;
                case "symbol":
                    return RangeEnum.Symbol;
                case "width":
                    return RangeEnum.Width;
            }
            throw new Exception("Cannot unmarshal type RangeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (RangeEnum)untypedValue;
            switch (value)
            {
                case RangeEnum.Category:
                    serializer.Serialize(writer, "category");
                    return;
                case RangeEnum.Diverging:
                    serializer.Serialize(writer, "diverging");
                    return;
                case RangeEnum.Heatmap:
                    serializer.Serialize(writer, "heatmap");
                    return;
                case RangeEnum.Height:
                    serializer.Serialize(writer, "height");
                    return;
                case RangeEnum.Ordinal:
                    serializer.Serialize(writer, "ordinal");
                    return;
                case RangeEnum.Ramp:
                    serializer.Serialize(writer, "ramp");
                    return;
                case RangeEnum.Symbol:
                    serializer.Serialize(writer, "symbol");
                    return;
                case RangeEnum.Width:
                    serializer.Serialize(writer, "width");
                    return;
            }
            throw new Exception("Cannot marshal type RangeEnum");
        }

        public static readonly RangeEnumConverter Singleton = new RangeEnumConverter();
    }

    internal class ScaleTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ScaleType) || t == typeof(ScaleType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "band":
                    return ScaleType.Band;
                case "bin-ordinal":
                    return ScaleType.BinOrdinal;
                case "identity":
                    return ScaleType.Identity;
                case "linear":
                    return ScaleType.Linear;
                case "log":
                    return ScaleType.Log;
                case "ordinal":
                    return ScaleType.Ordinal;
                case "point":
                    return ScaleType.Point;
                case "pow":
                    return ScaleType.Pow;
                case "quantile":
                    return ScaleType.Quantile;
                case "quantize":
                    return ScaleType.Quantize;
                case "sequential":
                    return ScaleType.Sequential;
                case "sqrt":
                    return ScaleType.Sqrt;
                case "symlog":
                    return ScaleType.Symlog;
                case "threshold":
                    return ScaleType.Threshold;
                case "time":
                    return ScaleType.Time;
                case "utc":
                    return ScaleType.Utc;
            }
            throw new Exception("Cannot unmarshal type ScaleType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ScaleType)untypedValue;
            switch (value)
            {
                case ScaleType.Band:
                    serializer.Serialize(writer, "band");
                    return;
                case ScaleType.BinOrdinal:
                    serializer.Serialize(writer, "bin-ordinal");
                    return;
                case ScaleType.Identity:
                    serializer.Serialize(writer, "identity");
                    return;
                case ScaleType.Linear:
                    serializer.Serialize(writer, "linear");
                    return;
                case ScaleType.Log:
                    serializer.Serialize(writer, "log");
                    return;
                case ScaleType.Ordinal:
                    serializer.Serialize(writer, "ordinal");
                    return;
                case ScaleType.Point:
                    serializer.Serialize(writer, "point");
                    return;
                case ScaleType.Pow:
                    serializer.Serialize(writer, "pow");
                    return;
                case ScaleType.Quantile:
                    serializer.Serialize(writer, "quantile");
                    return;
                case ScaleType.Quantize:
                    serializer.Serialize(writer, "quantize");
                    return;
                case ScaleType.Sequential:
                    serializer.Serialize(writer, "sequential");
                    return;
                case ScaleType.Sqrt:
                    serializer.Serialize(writer, "sqrt");
                    return;
                case ScaleType.Symlog:
                    serializer.Serialize(writer, "symlog");
                    return;
                case ScaleType.Threshold:
                    serializer.Serialize(writer, "threshold");
                    return;
                case ScaleType.Time:
                    serializer.Serialize(writer, "time");
                    return;
                case ScaleType.Utc:
                    serializer.Serialize(writer, "utc");
                    return;
            }
            throw new Exception("Cannot marshal type ScaleType");
        }

        public static readonly ScaleTypeConverter Singleton = new ScaleTypeConverter();
    }

    internal class EventsUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(EventsUnion) || t == typeof(EventsUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new EventsUnion { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<StreamClass>(reader);
                    return new EventsUnion { StreamClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<Listener[]>(reader);
                    return new EventsUnion { ListenerArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type EventsUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (EventsUnion)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.ListenerArray != null)
            {
                serializer.Serialize(writer, value.ListenerArray);
                return;
            }
            if (value.StreamClass != null)
            {
                serializer.Serialize(writer, value.StreamClass);
                return;
            }
            throw new Exception("Cannot marshal type EventsUnion");
        }

        public static readonly EventsUnionConverter Singleton = new EventsUnionConverter();
    }

    internal class UpdateConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Update) || t == typeof(Update?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Update { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<Expr>(reader);
                    return new Update { Expr = objectValue };
            }
            throw new Exception("Cannot unmarshal type Update");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Update)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.Expr != null)
            {
                serializer.Serialize(writer, value.Expr);
                return;
            }
            throw new Exception("Cannot marshal type Update");
        }

        public static readonly UpdateConverter Singleton = new UpdateConverter();
    }

    internal class PushConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Push) || t == typeof(Push?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "outer")
            {
                return Push.Outer;
            }
            throw new Exception("Cannot unmarshal type Push");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Push)untypedValue;
            if (value == Push.Outer)
            {
                serializer.Serialize(writer, "outer");
                return;
            }
            throw new Exception("Cannot marshal type Push");
        }

        public static readonly PushConverter Singleton = new PushConverter();
    }

    internal class TitleConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Title) || t == typeof(Title?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Title { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<TitleClass>(reader);
                    return new Title { TitleClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type Title");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Title)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.TitleClass != null)
            {
                serializer.Serialize(writer, value.TitleClass);
                return;
            }
            throw new Exception("Cannot marshal type Title");
        }

        public static readonly TitleConverter Singleton = new TitleConverter();
    }

    internal class FrameUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FrameUnion) || t == typeof(FrameUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "bounds":
                            return new FrameUnion { Enum = Frame.Bounds };
                        case "group":
                            return new FrameUnion { Enum = Frame.Group };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<DomainCapClass>(reader);
                    return new FrameUnion { DomainCapClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<DomainCapElement[]>(reader);
                    return new FrameUnion { DomainCapElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type FrameUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (FrameUnion)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case Frame.Bounds:
                        serializer.Serialize(writer, "bounds");
                        return;
                    case Frame.Group:
                        serializer.Serialize(writer, "group");
                        return;
                }
            }
            if (value.DomainCapElementArray != null)
            {
                serializer.Serialize(writer, value.DomainCapElementArray);
                return;
            }
            if (value.DomainCapClass != null)
            {
                serializer.Serialize(writer, value.DomainCapClass);
                return;
            }
            throw new Exception("Cannot marshal type FrameUnion");
        }

        public static readonly FrameUnionConverter Singleton = new FrameUnionConverter();
    }

    internal class FrameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Frame) || t == typeof(Frame?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "bounds":
                    return Frame.Bounds;
                case "group":
                    return Frame.Group;
            }
            throw new Exception("Cannot unmarshal type Frame");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Frame)untypedValue;
            switch (value)
            {
                case Frame.Bounds:
                    serializer.Serialize(writer, "bounds");
                    return;
                case Frame.Group:
                    serializer.Serialize(writer, "group");
                    return;
            }
            throw new Exception("Cannot marshal type Frame");
        }

        public static readonly FrameConverter Singleton = new FrameConverter();
    }

    internal class TitleOrientConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TitleOrient) || t == typeof(TitleOrient?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "bottom":
                            return new TitleOrient { Enum = TentacledOrient.Bottom };
                        case "left":
                            return new TitleOrient { Enum = TentacledOrient.Left };
                        case "none":
                            return new TitleOrient { Enum = TentacledOrient.None };
                        case "right":
                            return new TitleOrient { Enum = TentacledOrient.Right };
                        case "top":
                            return new TitleOrient { Enum = TentacledOrient.Top };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new TitleOrient { FormatTypeSignalRef = objectValue };
            }
            throw new Exception("Cannot unmarshal type TitleOrient");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TitleOrient)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case TentacledOrient.Bottom:
                        serializer.Serialize(writer, "bottom");
                        return;
                    case TentacledOrient.Left:
                        serializer.Serialize(writer, "left");
                        return;
                    case TentacledOrient.None:
                        serializer.Serialize(writer, "none");
                        return;
                    case TentacledOrient.Right:
                        serializer.Serialize(writer, "right");
                        return;
                    case TentacledOrient.Top:
                        serializer.Serialize(writer, "top");
                        return;
                }
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type TitleOrient");
        }

        public static readonly TitleOrientConverter Singleton = new TitleOrientConverter();
    }

    internal class TentacledOrientConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TentacledOrient) || t == typeof(TentacledOrient?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "bottom":
                    return TentacledOrient.Bottom;
                case "left":
                    return TentacledOrient.Left;
                case "none":
                    return TentacledOrient.None;
                case "right":
                    return TentacledOrient.Right;
                case "top":
                    return TentacledOrient.Top;
            }
            throw new Exception("Cannot unmarshal type TentacledOrient");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TentacledOrient)untypedValue;
            switch (value)
            {
                case TentacledOrient.Bottom:
                    serializer.Serialize(writer, "bottom");
                    return;
                case TentacledOrient.Left:
                    serializer.Serialize(writer, "left");
                    return;
                case TentacledOrient.None:
                    serializer.Serialize(writer, "none");
                    return;
                case TentacledOrient.Right:
                    serializer.Serialize(writer, "right");
                    return;
                case TentacledOrient.Top:
                    serializer.Serialize(writer, "top");
                    return;
            }
            throw new Exception("Cannot marshal type TentacledOrient");
        }

        public static readonly TentacledOrientConverter Singleton = new TentacledOrientConverter();
    }

    internal class TransformMarkAsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TransformMarkAs) || t == typeof(TransformMarkAs?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new TransformMarkAs { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FormatTypeSignalRef>(reader);
                    return new TransformMarkAs { FormatTypeSignalRef = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<AElement[]>(reader);
                    return new TransformMarkAs { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type TransformMarkAs");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TransformMarkAs)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.FormatTypeSignalRef != null)
            {
                serializer.Serialize(writer, value.FormatTypeSignalRef);
                return;
            }
            throw new Exception("Cannot marshal type TransformMarkAs");
        }

        public static readonly TransformMarkAsConverter Singleton = new TransformMarkAsConverter();
    }

    internal class TransformMarkTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TransformMarkType) || t == typeof(TransformMarkType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "bin":
                    return TransformMarkType.Bin;
                case "collect":
                    return TransformMarkType.Collect;
                case "crossfilter":
                    return TransformMarkType.Crossfilter;
                case "dotbin":
                    return TransformMarkType.Dotbin;
                case "extent":
                    return TransformMarkType.Extent;
                case "force":
                    return TransformMarkType.Force;
                case "formula":
                    return TransformMarkType.Formula;
                case "geojson":
                    return TransformMarkType.Geojson;
                case "geopath":
                    return TransformMarkType.Geopath;
                case "geopoint":
                    return TransformMarkType.Geopoint;
                case "geoshape":
                    return TransformMarkType.Geoshape;
                case "heatmap":
                    return TransformMarkType.Heatmap;
                case "identifier":
                    return TransformMarkType.Identifier;
                case "joinaggregate":
                    return TransformMarkType.Joinaggregate;
                case "label":
                    return TransformMarkType.Label;
                case "linkpath":
                    return TransformMarkType.Linkpath;
                case "lookup":
                    return TransformMarkType.Lookup;
                case "pack":
                    return TransformMarkType.Pack;
                case "partition":
                    return TransformMarkType.Partition;
                case "pie":
                    return TransformMarkType.Pie;
                case "resolvefilter":
                    return TransformMarkType.Resolvefilter;
                case "sample":
                    return TransformMarkType.Sample;
                case "stack":
                    return TransformMarkType.Stack;
                case "stratify":
                    return TransformMarkType.Stratify;
                case "timeunit":
                    return TransformMarkType.Timeunit;
                case "tree":
                    return TransformMarkType.Tree;
                case "treemap":
                    return TransformMarkType.Treemap;
                case "voronoi":
                    return TransformMarkType.Voronoi;
                case "window":
                    return TransformMarkType.Window;
                case "wordcloud":
                    return TransformMarkType.Wordcloud;
            }
            throw new Exception("Cannot unmarshal type TransformMarkType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TransformMarkType)untypedValue;
            switch (value)
            {
                case TransformMarkType.Bin:
                    serializer.Serialize(writer, "bin");
                    return;
                case TransformMarkType.Collect:
                    serializer.Serialize(writer, "collect");
                    return;
                case TransformMarkType.Crossfilter:
                    serializer.Serialize(writer, "crossfilter");
                    return;
                case TransformMarkType.Dotbin:
                    serializer.Serialize(writer, "dotbin");
                    return;
                case TransformMarkType.Extent:
                    serializer.Serialize(writer, "extent");
                    return;
                case TransformMarkType.Force:
                    serializer.Serialize(writer, "force");
                    return;
                case TransformMarkType.Formula:
                    serializer.Serialize(writer, "formula");
                    return;
                case TransformMarkType.Geojson:
                    serializer.Serialize(writer, "geojson");
                    return;
                case TransformMarkType.Geopath:
                    serializer.Serialize(writer, "geopath");
                    return;
                case TransformMarkType.Geopoint:
                    serializer.Serialize(writer, "geopoint");
                    return;
                case TransformMarkType.Geoshape:
                    serializer.Serialize(writer, "geoshape");
                    return;
                case TransformMarkType.Heatmap:
                    serializer.Serialize(writer, "heatmap");
                    return;
                case TransformMarkType.Identifier:
                    serializer.Serialize(writer, "identifier");
                    return;
                case TransformMarkType.Joinaggregate:
                    serializer.Serialize(writer, "joinaggregate");
                    return;
                case TransformMarkType.Label:
                    serializer.Serialize(writer, "label");
                    return;
                case TransformMarkType.Linkpath:
                    serializer.Serialize(writer, "linkpath");
                    return;
                case TransformMarkType.Lookup:
                    serializer.Serialize(writer, "lookup");
                    return;
                case TransformMarkType.Pack:
                    serializer.Serialize(writer, "pack");
                    return;
                case TransformMarkType.Partition:
                    serializer.Serialize(writer, "partition");
                    return;
                case TransformMarkType.Pie:
                    serializer.Serialize(writer, "pie");
                    return;
                case TransformMarkType.Resolvefilter:
                    serializer.Serialize(writer, "resolvefilter");
                    return;
                case TransformMarkType.Sample:
                    serializer.Serialize(writer, "sample");
                    return;
                case TransformMarkType.Stack:
                    serializer.Serialize(writer, "stack");
                    return;
                case TransformMarkType.Stratify:
                    serializer.Serialize(writer, "stratify");
                    return;
                case TransformMarkType.Timeunit:
                    serializer.Serialize(writer, "timeunit");
                    return;
                case TransformMarkType.Tree:
                    serializer.Serialize(writer, "tree");
                    return;
                case TransformMarkType.Treemap:
                    serializer.Serialize(writer, "treemap");
                    return;
                case TransformMarkType.Voronoi:
                    serializer.Serialize(writer, "voronoi");
                    return;
                case TransformMarkType.Window:
                    serializer.Serialize(writer, "window");
                    return;
                case TransformMarkType.Wordcloud:
                    serializer.Serialize(writer, "wordcloud");
                    return;
            }
            throw new Exception("Cannot marshal type TransformMarkType");
        }

        public static readonly TransformMarkTypeConverter Singleton = new TransformMarkTypeConverter();
    }

    internal class PaddingConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Padding) || t == typeof(Padding?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Padding { Double = doubleValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<SignalRef4>(reader);
                    return new Padding { SignalRef4 = objectValue };
            }
            throw new Exception("Cannot unmarshal type Padding");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Padding)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.SignalRef4 != null)
            {
                serializer.Serialize(writer, value.SignalRef4);
                return;
            }
            throw new Exception("Cannot marshal type Padding");
        }

        public static readonly PaddingConverter Singleton = new PaddingConverter();
    }
}
